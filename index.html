<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0, minimum-scale=1.0">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-fullscreen">
    <title>ESL Survivors 3D - PlayCanvas Edition</title>
    <script src="https://code.playcanvas.org/playcanvas-stable.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap" rel="stylesheet">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            margin: 0;
            background-color: #000;
            color: #00ff00;
            font-family: 'Orbitron', monospace;
            overflow: hidden;
            touch-action: none;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
        }
        #application-canvas {
            width: 100%;
            height: 100%;
            position: absolute;
            top: 0;
            left: 0;
        }
        .modal {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 20, 0, 0.95);
            padding: 3rem;
            border-radius: 20px;
            border: 3px solid #00ff00;
            box-shadow: 0 0 40px rgba(0, 255, 0, 0.8);
            text-align: center;
            z-index: 100;
            width: 90%;
            max-width: 700px;
            font-family: 'Orbitron', monospace;
            touch-action: auto;
        }
        .modal h1, .modal h2 {
            color: #00ff00;
            text-shadow: 0 0 10px #00ff00;
            font-size: 2.5rem;
            margin-bottom: 1.5rem;
        }
        .modal p {
            color: #00ff00;
            font-size: 1.2rem;
            margin-bottom: 1rem;
        }
        .modal-button {
            background-color: #00ff00;
            color: #000;
            font-family: 'Orbitron', monospace;
            font-size: 1.8rem;
            font-weight: bold;
            padding: 1.2rem 2rem;
            border-radius: 15px;
            border: 3px solid #00ff00;
            cursor: pointer;
            transition: all 0.2s ease;
            margin-top: 1.5rem;
            box-shadow: 0 6px #00aa00;
            min-height: 80px;
            touch-action: manipulation;
        }
        .modal-button:active {
            background-color: #00aa00;
            box-shadow: 0 2px #00aa00;
            transform: translateY(4px);
        }
        #xp-bar-container {
            width: 100%;
            height: 20px;
            background-color: #001100;
            border: 3px solid #00ff00;
            border-radius: 10px;
            overflow: hidden;
        }
        #xp-bar-fill {
            height: 100%;
            background: linear-gradient(90deg, #00ff00, #00aa00);
            width: 0%;
            transition: width 0.3s ease;
        }
        #touch-controls-container {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            top: 0;
            z-index: 20;
            pointer-events: none;
        }
        .joystick-area {
            position: absolute;
            bottom: 40px;
            left: 40px;
            width: 200px;
            height: 200px;
            background-color: rgba(0, 255, 0, 0.1);
            border: 4px solid rgba(0, 255, 0, 0.5);
            border-radius: 50%;
            pointer-events: auto;
            touch-action: none;
        }
        .joystick-nub {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 80px;
            height: 80px;
            background-color: rgba(0, 255, 0, 0.6);
            border: 4px solid rgba(0, 255, 0, 1);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            box-shadow: 0 0 20px rgba(0, 255, 0, 0.8);
        }
        #shoot-area {
            position: absolute;
            bottom: 0;
            right: 0;
            top: 0;
            left: 50%;
            pointer-events: auto;
            touch-action: none;
        }

        .touch-dash-button {
            position: absolute;
            bottom: 180px;
            right: 40px;
            width: 110px;
            height: 110px;
            background-color: rgba(0, 200, 0, 0.6);
            border: 4px solid rgba(0, 255, 0, 1);
            border-radius: 50%;
            pointer-events: auto;
            display: flex;
            align-items: center;
            justify-content: center;
            font-family: 'Orbitron', monospace;
            font-size: 1.5rem;
            font-weight: bold;
            color: white;
            z-index: 21;
            overflow: hidden;
            box-shadow: 0 0 25px rgba(0, 255, 0, 0.6);
            touch-action: manipulation;
        }
        .touch-dash-cooldown {
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background-color: rgba(0, 0, 0, 0.8);
            transform: translateY(100%);
            transition: transform 0.1s linear;
        }

        .touch-bomb-button {
            position: absolute;
            bottom: 320px;
            right: 40px;
            width: 110px;
            height: 110px;
            background-color: rgba(255, 100, 0, 0.6);
            border: 4px solid rgba(255, 150, 0, 1);
            border-radius: 50%;
            pointer-events: auto;
            display: flex;
            align-items: center;
            justify-content: center;
            font-family: 'Orbitron', monospace;
            font-size: 2.5rem;
            color: white;
            z-index: 21;
            box-shadow: 0 0 25px rgba(255, 100, 0, 0.6);
            touch-action: manipulation;
        }

        .touch-question-button {
            position: absolute;
            bottom: 40px;
            right: 40px;
            width: 130px;
            height: 130px;
            background-color: rgba(0, 255, 255, 0.6);
            border: 4px solid rgba(0, 255, 255, 1);
            border-radius: 50%;
            pointer-events: auto;
            display: flex;
            align-items: center;
            justify-content: center;
            font-family: 'Orbitron', monospace;
            font-size: 4rem;
            font-weight: bold;
            color: white;
            z-index: 21;
            box-shadow: 0 0 30px rgba(0, 255, 255, 0.8);
            touch-action: manipulation;
        }

        #hud {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            padding: 20px;
            font-size: 1.3rem;
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            color: #00ff00;
            background: linear-gradient(180deg, rgba(0,0,0,0.7) 0%, rgba(0,0,0,0) 100%);
            text-shadow: 0 0 5px #00ff00;
            z-index: 10;
        }

        #xp-hud {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            padding: 20px;
            background: linear-gradient(0deg, rgba(0,0,0,0.7) 0%, rgba(0,0,0,0) 100%);
            z-index: 10;
        }

        .hud-section {
            background: rgba(0, 255, 0, 0.1);
            padding: 15px;
            border: 2px solid #00ff00;
            border-radius: 10px;
        }

        .hidden { display: none !important; }
    </style>
</head>
<body>
    <canvas id="application-canvas"></canvas>

    <div id="touch-controls-container" class="hidden">
        <div id="joystick-area" class="joystick-area">
            <div id="joystick-nub" class="joystick-nub"></div>
        </div>
        <div id="shoot-area"></div>
        <div id="touch-bomb-button" class="touch-bomb-button">ðŸ’£</div>
        <div id="touch-dash-button" class="touch-dash-button">
            DASH
            <div id="touch-dash-cooldown" class="touch-dash-cooldown"></div>
        </div>
        <div id="touch-question-button" class="touch-question-button">?</div>
    </div>

    <div id="hud" class="hidden">
        <div class="hud-section">
            <div>Ammo: <span id="ammo-text">50</span></div>
            <div>Bombs: <span id="bomb-text">3</span></div>
            <div>Score: <span id="score-text">0</span></div>
        </div>
        <div class="hud-section">
            <div>Level: <span id="level-text">1</span></div>
            <div>Biome: <span id="biome-text">Normal</span></div>
        </div>
        <div class="hud-section">
            <div>Time: <span id="time-text">0s</span></div>
        </div>
    </div>

    <div id="xp-hud" class="hidden">
        <div id="xp-bar-container">
            <div id="xp-bar-fill"></div>
        </div>
    </div>

    <div id="question-modal" class="modal hidden">
        <h2>Ammo Question!</h2>
        <p id="question-text" style="font-size: 1.5rem; margin: 2rem 0;"></p>
        <div id="answer-buttons" style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px;"></div>
    </div>

    <div id="level-up-modal" class="modal hidden">
        <h2>Level Up!</h2>
        <p>Choose an upgrade:</p>
        <div id="upgrade-options-container" style="display: flex; flex-direction: column; gap: 20px; margin-top: 20px;"></div>
    </div>

    <div id="game-over-modal" class="modal hidden">
        <h2 style="color: #ff0000; text-shadow: 0 0 10px #ff0000;">Game Over!</h2>
        <div style="text-align: left; font-size: 1.3rem; margin: 2rem 0; background: rgba(0,0,0,0.5); padding: 20px; border-radius: 10px;">
            <p>Enemies Defeated: <span id="final-score" style="float: right; font-weight: bold;">0</span></p>
            <p>Time Survived: <span id="final-time" style="float: right; font-weight: bold;">0s</span></p>
            <hr style="margin: 15px 0; border-color: #00ff00;">
            <p>Correct: <span id="final-questions-correct" style="float: right; color: #00ff00; font-weight: bold;">0</span></p>
            <p>Incorrect: <span id="final-questions-incorrect" style="float: right; color: #ff0000; font-weight: bold;">0</span></p>
        </div>
        <button id="restart-button" class="modal-button">Play Again</button>
    </div>

    <script type="module">
        // PlayCanvas Application Setup
        const canvas = document.getElementById('application-canvas');
        const app = new pc.Application(canvas, {
            mouse: new pc.Mouse(document.body),
            touch: new pc.TouchDevice(document.body),
            keyboard: new pc.Keyboard(window),
        });

        app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);
        app.setCanvasResolution(pc.RESOLUTION_AUTO);

        // Start the application
        app.start();

        // Resize canvas
        window.addEventListener('resize', () => app.resizeCanvas());

        // === Game State ===
        const gameState = {
            player: null,
            enemies: [],
            projectiles: [],
            enemyProjectiles: [],
            xpOrbs: [],
            particles: [],
            score: 0,
            gameTime: 0,
            spawnTimer: 0,
            gamePaused: false,
            gameOver: false,
            correctAnswers: 0,
            incorrectAnswers: 0,
            bossSpawnedLevel3: false,
            bossSpawnedLevel5: false,
            bossSpawnedLevel10: false,
            lastShotTime: 0,
            currentBiome: 'normal',
            biomeIndex: 0,
            isTouchDevice: false,
            joystickTouchId: null,
            joystickStart: { x: 0, y: 0 },
            moveInput: { x: 0, y: 0 },
            activeTouches: {},
            keys: {}
        };

        const playerStats = {
            speed: 5,
            health: 100,
            maxHealth: 100,
            ammo: 50,
            fireRate: 500,
            projectileSpeed: 15,
            projectileDamage: 25,
            shotCount: 1,
            pickupRadius: 80,
            level: 1,
            xp: 0,
            xpToNextLevel: 100,
            pierce: 0,
            dashSpeed: 25,
            dashDuration: 150,
            dashCooldown: 5000,
            lastDashTime: 0,
            isDashing: false,
            dashTimer: 0,
            bombs: 3,
            bombDamage: 100,
            bombRadius: 200,
            bombCooldown: 10000,
            lastBombTime: -10000
        };

        const world = { width: 200, height: 200 };

        const biomes = {
            normal: { name: 'Normal World', color: new pc.Color(0, 1, 0), gridColor: new pc.Color(0, 0.2, 0), friction: 0.85 },
            ice: { name: 'Ice World', color: new pc.Color(0, 1, 1), gridColor: new pc.Color(0, 0.2, 0.2), friction: 0.92 },
            heat: { name: 'Heat World', color: new pc.Color(1, 0, 0), gridColor: new pc.Color(0.2, 0, 0), friction: 0.85 }
        };
        const biomeOrder = ['normal', 'ice', 'heat', 'normal'];

        const enemyTypes = [
            { id_key: "Drone", name: "Drone", size: 2, speed: 3.6, health: 40, xp: 10, color: new pc.Color(1, 0, 0), damage: 5, maxHealth: 40 },
            { id_key: "Robot", name: "Robot", size: 5, speed: 0.8, health: 120, xp: 40, color: new pc.Color(0, 0, 1), damage: 10, maxHealth: 120 },
            { id_key: "Scout", name: "Scout", size: 1.5, speed: 4.4, health: 30, xp: 18, color: new pc.Color(1, 1, 0), damage: 4, maxHealth: 30 },
            { id_key: "Swarm", name: "Swarm", size: 0.7, speed: 5, health: 10, xp: 15, color: new pc.Color(0, 1, 0.53), damage: 1, maxHealth: 10 },
            { id_key: "Tank", name: "Tank", size: 7, speed: 0.6, health: 300, xp: 60, color: new pc.Color(0.4, 0.4, 0.4), damage: 20, maxHealth: 300 }
        ];

        const bossType = {
            id_key: "Boss", name: "Boss", size: 8, speed: 1.8, health: 900, xp: 2000,
            color: new pc.Color(1, 0, 0), damage: 250, maxHealth: 900, isBoss: true,
            shootCooldown: 2000, lastShotTime: 0
        };

        const powerUpTypes = {
            'HEALTH': { name: "Health Pack", description: "+50 Max HP", apply: (p) => { p.maxHealth += 50; p.health = Math.min(p.maxHealth, p.health + 50); } },
            'SPEED': { name: "Speed Boost", description: "+80% Move Speed", apply: (p) => p.speed *= 1.8 },
            'FIRE_RATE': { name: "Rapid Fire", description: "-75% Firing Delay", apply: (p) => p.fireRate *= 0.25 },
            'DAMAGE': { name: "Damage Up", description: "+15 Damage", apply: (p) => p.projectileDamage += 15 },
            'MULTISHOT': { name: "Spread Shot", description: "+2 Projectiles", apply: (p) => p.shotCount += 2 },
            'PIERCE': { name: "Piercing Shot", description: "Shots pierce +2 enemies", apply: (p) => p.pierce += 2 },
            'PICKUP': { name: "XP Magnet", description: "+75% Pickup Radius", apply: (p) => p.pickupRadius *= 1.75 },
            'BOMB_CAPACITY': { name: "Bomb Cache", description: "+2 Bombs", apply: (p) => p.bombs += 2 },
            'DASH_COOLDOWN': { name: "Quick Dash", description: "-30% Dash Cooldown", apply: (p) => p.dashCooldown *= 0.7 }
        };

        // Question Generator
        const questionGenerator = {
            verbBank: [
                { base: 'go', past: 'went', ing: 'going', pastParticiple: 'gone', object: 'to the store' },
                { base: 'eat', past: 'ate', ing: 'eating', pastParticiple: 'eaten', object: 'pizza' },
                { base: 'sleep', past: 'slept', ing: 'sleeping', pastParticiple: 'slept', object: 'well' },
                { base: 'run', past: 'ran', ing: 'running', pastParticiple: 'run', object: 'fast' }
            ],
            subjects: [
                { s: 'I', was: 'was' }, { s: 'You', was: 'were' }, { s: 'He', was: 'was' },
                { s: 'She', was: 'was' }, { s: 'They', was: 'were' }
            ],
            timeClauses: ['yesterday', 'last night', 'at 8 PM', 'last week'],
            getRandom(arr) { return arr[Math.floor(Math.random() * arr.length)]; },
            shuffle(arr) {
                let newArr = [...arr];
                for (let i = newArr.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [newArr[i], newArr[j]] = [newArr[j], newArr[i]];
                }
                return newArr;
            },
            createPastSimpleFill() {
                const verb = this.getRandom(this.verbBank);
                const subject = this.getRandom(this.subjects).s;
                const time = this.getRandom(this.timeClauses);
                const q = `${subject} [___] ${verb.object} ${time}.`;
                let answers = [verb.past, verb.base, verb.ing, verb.base + 's'];
                const shuffledAnswers = this.shuffle(answers);
                return { q, a: shuffledAnswers, c: shuffledAnswers.indexOf(verb.past) };
            },
            generate() {
                return this.createPastSimpleFill();
            }
        };

        // === UI Elements ===
        const getEl = id => document.getElementById(id);
        const hud = getEl('hud');
        const ammoText = getEl('ammo-text');
        const bombText = getEl('bomb-text');
        const scoreText = getEl('score-text');
        const levelText = getEl('level-text');
        const biomeText = getEl('biome-text');
        const timeText = getEl('time-text');
        const xp_hud = getEl('xp-hud');
        const xpBarFill = getEl('xp-bar-fill');
        const questionModal = getEl('question-modal');
        const questionText = getEl('question-text');
        const answerButtons = getEl('answer-buttons');
        const levelUpModal = getEl('level-up-modal');
        const upgradeOptionsContainer = getEl('upgrade-options-container');
        const gameOverModal = getEl('game-over-modal');
        const finalScore = getEl('final-score');
        const finalTime = getEl('final-time');
        const finalQuestionsCorrect = getEl('final-questions-correct');
        const finalQuestionsIncorrect = getEl('final-questions-incorrect');
        const restartButton = getEl('restart-button');
        const touchControlsContainer = getEl('touch-controls-container');
        const joystickArea = getEl('joystick-area');
        const joystickNub = getEl('joystick-nub');
        const shootArea = getEl('shoot-area');
        const touchQuestionButton = getEl('touch-question-button');
        const touchDashButton = getEl('touch-dash-button');
        const touchDashCooldown = getEl('touch-dash-cooldown');
        const touchBombButton = getEl('touch-bomb-button');

        // === PlayCanvas Scene Setup ===
        function createCamera() {
            const cameraEntity = new pc.Entity('camera');
            cameraEntity.addComponent('camera', {
                clearColor: new pc.Color(0, 0, 0),
                farClip: 500,
                fov: 60
            });
            cameraEntity.setPosition(0, 20, -50);
            cameraEntity.lookAt(0, 0, 0);
            app.root.addChild(cameraEntity);
            return cameraEntity;
        }

        function createLight() {
            const light = new pc.Entity('light');
            light.addComponent('light', {
                type: 'directional',
                color: biomes[gameState.currentBiome].color,
                intensity: 1
            });
            light.setEulerAngles(45, 30, 0);
            app.root.addChild(light);
            return light;
        }

        function createAmbientLight() {
            const ambient = new pc.Entity('ambient');
            ambient.addComponent('light', {
                type: 'directional',
                color: new pc.Color(0.3, 0.3, 0.3),
                intensity: 0.5
            });
            ambient.setEulerAngles(-45, 0, 0);
            app.root.addChild(ambient);
            return ambient;
        }

        function createGrid() {
            const gridEntity = new pc.Entity('grid');
            const gridSize = 200;
            const divisions = 40;
            const step = gridSize / divisions;

            const positions = [];
            for (let i = 0; i <= divisions; i++) {
                const pos = -gridSize / 2 + i * step;
                // Lines parallel to X axis
                positions.push(-gridSize / 2, 0, pos);
                positions.push(gridSize / 2, 0, pos);
                // Lines parallel to Z axis
                positions.push(pos, 0, -gridSize / 2);
                positions.push(pos, 0, gridSize / 2);
            }

            const mesh = new pc.Mesh(app.graphicsDevice);
            mesh.clear(true, false);

            const vertexFormat = new pc.VertexFormat(app.graphicsDevice, [
                { semantic: pc.SEMANTIC_POSITION, components: 3, type: pc.TYPE_FLOAT32 }
            ]);

            const vertexBuffer = new pc.VertexBuffer(app.graphicsDevice, vertexFormat, positions.length / 3);
            vertexBuffer.setData(new Float32Array(positions));

            mesh.vertexBuffer = vertexBuffer;
            mesh.primitive[0].type = pc.PRIMITIVE_LINES;
            mesh.primitive[0].base = 0;
            mesh.primitive[0].count = positions.length / 3;
            mesh.primitive[0].indexed = false;

            const material = new pc.BasicMaterial();
            material.color = biomes[gameState.currentBiome].gridColor;
            material.update();

            const meshInstance = new pc.MeshInstance(mesh, material);

            gridEntity.addComponent('render', {
                meshInstances: [meshInstance],
                castShadows: false
            });

            app.root.addChild(gridEntity);
            gridEntity.userData = { type: 'grid' };
            return gridEntity;
        }

        function createWireframeMaterial(color, lineWidth = 2) {
            const material = new pc.BasicMaterial();
            material.color = color;
            material.update();
            return material;
        }

        function createWireframePyramid(size, color) {
            const entity = new pc.Entity('player');

            const height = size * 2;
            const baseSize = size;

            const positions = [
                // Base triangle
                0, 0, -baseSize,
                baseSize, 0, baseSize,
                -baseSize, 0, baseSize,
                // Apex
                0, height, 0
            ];

            const indices = [
                // Base
                0, 1,
                1, 2,
                2, 0,
                // Sides
                0, 3,
                1, 3,
                2, 3
            ];

            const mesh = new pc.Mesh(app.graphicsDevice);
            mesh.clear(true, false);

            const vertexFormat = new pc.VertexFormat(app.graphicsDevice, [
                { semantic: pc.SEMANTIC_POSITION, components: 3, type: pc.TYPE_FLOAT32 }
            ]);

            const vertexBuffer = new pc.VertexBuffer(app.graphicsDevice, vertexFormat, positions.length / 3);
            vertexBuffer.setData(new Float32Array(positions));

            const indexBuffer = new pc.IndexBuffer(app.graphicsDevice, pc.INDEXFORMAT_UINT16, indices.length);
            indexBuffer.setData(new Uint16Array(indices));

            mesh.vertexBuffer = vertexBuffer;
            mesh.indexBuffer[0] = indexBuffer;
            mesh.primitive[0].type = pc.PRIMITIVE_LINES;
            mesh.primitive[0].base = 0;
            mesh.primitive[0].count = indices.length;
            mesh.primitive[0].indexed = true;

            const material = createWireframeMaterial(color);
            const meshInstance = new pc.MeshInstance(mesh, material);

            entity.addComponent('render', {
                meshInstances: [meshInstance],
                castShadows: false
            });

            entity.addComponent('collision', {
                type: 'sphere',
                radius: size
            });

            entity.addComponent('rigidbody', {
                type: 'kinematic',
                restitution: 0
            });

            return entity;
        }

        function createWireframeCube(size, color) {
            const entity = new pc.Entity('enemy');

            const s = size / 2;
            const positions = [
                -s, -s, -s,  s, -s, -s,  s,  s, -s, -s,  s, -s,  // Back face
                -s, -s,  s,  s, -s,  s,  s,  s,  s, -s,  s,  s   // Front face
            ];

            const indices = [
                // Back face
                0, 1,  1, 2,  2, 3,  3, 0,
                // Front face
                4, 5,  5, 6,  6, 7,  7, 4,
                // Connecting edges
                0, 4,  1, 5,  2, 6,  3, 7
            ];

            const mesh = new pc.Mesh(app.graphicsDevice);
            mesh.clear(true, false);

            const vertexFormat = new pc.VertexFormat(app.graphicsDevice, [
                { semantic: pc.SEMANTIC_POSITION, components: 3, type: pc.TYPE_FLOAT32 }
            ]);

            const vertexBuffer = new pc.VertexBuffer(app.graphicsDevice, vertexFormat, positions.length / 3);
            vertexBuffer.setData(new Float32Array(positions));

            const indexBuffer = new pc.IndexBuffer(app.graphicsDevice, pc.INDEXFORMAT_UINT16, indices.length);
            indexBuffer.setData(new Uint16Array(indices));

            mesh.vertexBuffer = vertexBuffer;
            mesh.indexBuffer[0] = indexBuffer;
            mesh.primitive[0].type = pc.PRIMITIVE_LINES;
            mesh.primitive[0].base = 0;
            mesh.primitive[0].count = indices.length;
            mesh.primitive[0].indexed = true;

            const material = createWireframeMaterial(color);
            const meshInstance = new pc.MeshInstance(mesh, material);

            entity.addComponent('render', {
                meshInstances: [meshInstance],
                castShadows: false
            });

            entity.addComponent('collision', {
                type: 'sphere',
                radius: size
            });

            entity.addComponent('rigidbody', {
                type: 'kinematic',
                restitution: 0
            });

            return entity;
        }

        function createSphere(size, color, emissive = true) {
            const entity = new pc.Entity('sphere');

            entity.addComponent('render', {
                type: 'sphere',
                castShadows: false
            });

            const material = new pc.StandardMaterial();
            material.diffuse = color;
            if (emissive) {
                material.emissive = color;
                material.emissiveIntensity = 0.5;
            }
            material.update();

            entity.render.meshInstances[0].material = material;
            entity.setLocalScale(size, size, size);

            entity.addComponent('collision', {
                type: 'sphere',
                radius: size
            });

            entity.addComponent('rigidbody', {
                type: 'kinematic',
                restitution: 0
            });

            return entity;
        }

        // === Game Systems ===
        let cameraEntity, lightEntity, ambientLightEntity, gridEntity;

        function initGame() {
            // Clear existing entities
            const entitiesToRemove = [];
            app.root.children.forEach(child => {
                if (child.userData && (child.userData.type === 'player' || child.userData.type === 'enemy' ||
                    child.userData.type === 'projectile' || child.userData.type === 'xp' ||
                    child.userData.type === 'particle' || child.userData.type === 'grid')) {
                    entitiesToRemove.push(child);
                }
            });
            entitiesToRemove.forEach(e => {
                app.root.removeChild(e);
                e.destroy();
            });

            // Reset game state
            gameState.enemies = [];
            gameState.projectiles = [];
            gameState.enemyProjectiles = [];
            gameState.xpOrbs = [];
            gameState.particles = [];
            gameState.score = 0;
            gameState.gameTime = 0;
            gameState.spawnTimer = 0;
            gameState.gamePaused = false;
            gameState.gameOver = false;
            gameState.correctAnswers = 0;
            gameState.incorrectAnswers = 0;
            gameState.bossSpawnedLevel3 = false;
            gameState.bossSpawnedLevel5 = false;
            gameState.bossSpawnedLevel10 = false;
            gameState.lastShotTime = 0;
            gameState.currentBiome = 'normal';
            gameState.biomeIndex = 0;

            // Reset player stats
            Object.assign(playerStats, {
                speed: 5,
                health: 100,
                maxHealth: 100,
                ammo: 50,
                fireRate: 500,
                projectileSpeed: 15,
                projectileDamage: 25,
                shotCount: 1,
                pickupRadius: 80,
                level: 1,
                xp: 0,
                xpToNextLevel: 100,
                pierce: 0,
                dashSpeed: 25,
                dashDuration: 150,
                dashCooldown: 5000,
                lastDashTime: 0,
                isDashing: false,
                dashTimer: 0,
                bombs: 3,
                bombDamage: 100,
                bombRadius: 200,
                bombCooldown: 10000,
                lastBombTime: -10000,
                vx: 0,
                vy: 0,
                weaponAngle: 0
            });

            // Create scene
            if (!cameraEntity) cameraEntity = createCamera();
            if (!lightEntity) lightEntity = createLight();
            if (!ambientLightEntity) ambientLightEntity = createAmbientLight();

            // Recreate grid
            if (gridEntity) {
                app.root.removeChild(gridEntity);
                gridEntity.destroy();
            }
            gridEntity = createGrid();

            // Create player
            if (gameState.player) {
                app.root.removeChild(gameState.player);
                gameState.player.destroy();
            }
            gameState.player = createWireframePyramid(2, biomes[gameState.currentBiome].color);
            gameState.player.setPosition(0, 0, 0);
            gameState.player.userData = {
                type: 'player',
                stats: playerStats
            };
            app.root.addChild(gameState.player);

            // Update UI
            updateHUD();
            [questionModal, levelUpModal, gameOverModal].forEach(m => m?.classList.add('hidden'));
        }

        function startGame() {
            hud?.classList.remove('hidden');
            xp_hud?.classList.remove('hidden');
            initGame();
        }

        function endGame() {
            gameState.gameOver = true;
            gameState.gamePaused = true;
            if (finalScore) finalScore.textContent = gameState.score;
            if (finalTime) finalTime.textContent = Math.floor(gameState.gameTime) + 's';
            if (finalQuestionsCorrect) finalQuestionsCorrect.textContent = gameState.correctAnswers;
            if (finalQuestionsIncorrect) finalQuestionsIncorrect.textContent = gameState.incorrectAnswers;
            gameOverModal?.classList.remove('hidden');
        }

        function spawnEnemy() {
            const type = enemyTypes[Math.floor(Math.random() * enemyTypes.length)];
            const spawnDist = 60;
            const angle = Math.random() * Math.PI * 2;
            const x = gameState.player.getPosition().x + Math.cos(angle) * spawnDist;
            const z = gameState.player.getPosition().z + Math.sin(angle) * spawnDist;

            const enemy = createWireframeCube(type.size, type.color);
            enemy.setPosition(x, 0, z);
            enemy.userData = {
                type: 'enemy',
                ...type,
                id: Math.random(),
                health: type.health * (1 + gameState.gameTime / 90),
                maxHealth: type.health * (1 + gameState.gameTime / 90)
            };

            app.root.addChild(enemy);
            gameState.enemies.push(enemy);
        }

        function spawnBoss() {
            const spawnDist = 70;
            const angle = Math.random() * Math.PI * 2;
            const x = gameState.player.getPosition().x + Math.cos(angle) * spawnDist;
            const z = gameState.player.getPosition().z + Math.sin(angle) * spawnDist;

            const boss = createWireframeCube(bossType.size, bossType.color);
            boss.setPosition(x, 0, z);
            boss.userData = {
                type: 'enemy',
                ...bossType,
                id: Math.random(),
                health: bossType.health,
                maxHealth: bossType.health,
                lastShotTime: Date.now()
            };

            app.root.addChild(boss);
            gameState.enemies.push(boss);
        }

        function shoot(angle) {
            if (playerStats.ammo <= 0) {
                askQuestion();
                return;
            }
            if (Date.now() - gameState.lastShotTime < playerStats.fireRate) return;

            playerStats.ammo--;
            gameState.lastShotTime = Date.now();
            const spreadAngle = 0.15;

            for (let i = 0; i < playerStats.shotCount; i++) {
                let currentAngle = angle;
                if (playerStats.shotCount > 1) {
                    const totalSpread = spreadAngle * (playerStats.shotCount - 1);
                    currentAngle += totalSpread / 2 - spreadAngle * i;
                }

                const projectile = createSphere(0.4, biomes[gameState.currentBiome].color);
                const playerPos = gameState.player.getPosition();
                projectile.setPosition(playerPos.x, playerPos.y, playerPos.z);

                const speed = playerStats.projectileSpeed;
                projectile.userData = {
                    type: 'projectile',
                    vx: Math.cos(currentAngle) * speed,
                    vz: Math.sin(currentAngle) * speed,
                    damage: playerStats.projectileDamage,
                    lifetime: 3,
                    pierceCount: playerStats.pierce,
                    hitEnemies: []
                };

                app.root.addChild(projectile);
                gameState.projectiles.push(projectile);
            }
        }

        function bossShoot(boss) {
            if (!gameState.player) return;
            const bossPos = boss.getPosition();
            const playerPos = gameState.player.getPosition();

            const dx = playerPos.x - bossPos.x;
            const dz = playerPos.z - bossPos.z;
            const angle = Math.atan2(dz, dx);
            const speed = 8;

            const projectile = createSphere(0.5, new pc.Color(1, 0, 0));
            projectile.setPosition(bossPos.x, bossPos.y, bossPos.z);

            projectile.userData = {
                type: 'enemyProjectile',
                vx: Math.cos(angle) * speed,
                vz: Math.sin(angle) * speed,
                damage: 20,
                lifetime: 5
            };

            app.root.addChild(projectile);
            gameState.enemyProjectiles.push(projectile);
        }

        function createXpOrb(x, y, z, value) {
            const orb = createSphere(0.3, new pc.Color(0, 1, 0));
            orb.setPosition(x, y, z);
            orb.userData = {
                type: 'xp',
                value: value
            };

            app.root.addChild(orb);
            gameState.xpOrbs.push(orb);
        }

        function gainXp(amount) {
            playerStats.xp += amount;
            if (playerStats.xp >= playerStats.xpToNextLevel) {
                playerStats.level++;
                playerStats.xp -= playerStats.xpToNextLevel;
                playerStats.xpToNextLevel = Math.floor(playerStats.xpToNextLevel * 1.5);
                showLevelUpModal();
            }
        }

        function triggerDash() {
            if (!gameState.player || playerStats.isDashing || gameState.gamePaused) return;
            const now = Date.now();
            if (now - playerStats.lastDashTime < playerStats.dashCooldown) return;

            playerStats.lastDashTime = now;
            playerStats.isDashing = true;
            playerStats.dashTimer = playerStats.dashDuration / 1000;

            let dashDirX = playerStats.vx;
            let dashDirZ = playerStats.vy;
            let mag = Math.hypot(dashDirX, dashDirZ);

            if (mag < 1) {
                dashDirX = Math.cos(playerStats.weaponAngle);
                dashDirZ = Math.sin(playerStats.weaponAngle);
            } else {
                dashDirX /= mag;
                dashDirZ /= mag;
            }

            playerStats.dashTargetVX = dashDirX * playerStats.dashSpeed;
            playerStats.dashTargetVZ = dashDirZ * playerStats.dashSpeed;

            if (touchDashCooldown) {
                touchDashCooldown.style.transition = 'none';
                touchDashCooldown.style.transform = 'translateY(0%)';
            }
        }

        function triggerBomb() {
            if (!gameState.player || gameState.gamePaused) return;
            if (playerStats.bombs <= 0) return;
            const now = Date.now();
            if (now - playerStats.lastBombTime < playerStats.bombCooldown) return;

            playerStats.bombs--;
            playerStats.lastBombTime = now;

            const playerPos = gameState.player.getPosition();

            for (let i = gameState.enemies.length - 1; i >= 0; i--) {
                const e = gameState.enemies[i];
                const enemyPos = e.getPosition();
                const dx = enemyPos.x - playerPos.x;
                const dz = enemyPos.z - playerPos.z;
                const dist = Math.sqrt(dx * dx + dz * dz);

                if (dist < playerStats.bombRadius / 10) {
                    handleEnemyHit(e, playerStats.bombDamage, i);
                }
            }

            for (let i = gameState.enemyProjectiles.length - 1; i >= 0; i--) {
                const p = gameState.enemyProjectiles[i];
                const projPos = p.getPosition();
                const dx = projPos.x - playerPos.x;
                const dz = projPos.z - playerPos.z;
                const dist = Math.sqrt(dx * dx + dz * dz);

                if (dist < playerStats.bombRadius / 10) {
                    app.root.removeChild(p);
                    p.destroy();
                    gameState.enemyProjectiles.splice(i, 1);
                }
            }
        }

        function handleEnemyHit(enemy, damage, index) {
            enemy.userData.health -= damage;
            if (enemy.userData.health <= 0) {
                killEnemy(enemy, index);
            }
        }

        function killEnemy(enemy, index) {
            gameState.score++;
            const pos = enemy.getPosition();
            createXpOrb(pos.x, pos.y, pos.z, enemy.userData.xp);

            if (enemy.userData.isBoss) {
                changeBiome();
            }

            app.root.removeChild(enemy);
            enemy.destroy();
            gameState.enemies.splice(index, 1);
        }

        function changeBiome() {
            gameState.biomeIndex = (gameState.biomeIndex + 1) % biomeOrder.length;
            gameState.currentBiome = biomeOrder[gameState.biomeIndex];

            // Update light color
            if (lightEntity) {
                lightEntity.light.color = biomes[gameState.currentBiome].color;
            }

            // Update grid
            if (gridEntity) {
                const material = gridEntity.render.meshInstances[0].material;
                material.color = biomes[gameState.currentBiome].gridColor;
                material.update();
            }

            // Update player color
            if (gameState.player) {
                const material = gameState.player.render.meshInstances[0].material;
                material.color = biomes[gameState.currentBiome].color;
                material.update();
            }
        }

        function showLevelUpModal() {
            gameState.gamePaused = true;
            if (!upgradeOptionsContainer) return;
            upgradeOptionsContainer.innerHTML = '';
            const availableUpgrades = Object.keys(powerUpTypes);
            const chosenUpgrades = [];
            while (chosenUpgrades.length < 3 && availableUpgrades.length > 0) {
                const randIndex = Math.floor(Math.random() * availableUpgrades.length);
                chosenUpgrades.push(availableUpgrades.splice(randIndex, 1)[0]);
            }
            chosenUpgrades.forEach(key => {
                const upgrade = powerUpTypes[key];
                const button = document.createElement('button');
                button.className = "modal-button";
                button.style.cssText = "background: rgba(0,255,0,0.2); border: 3px solid #00ff00; padding: 20px; text-align: left; width: 100%;";
                button.innerHTML = `<div style="font-size: 1.5rem; font-weight: bold; color: #00ff00; margin-bottom: 10px;">${upgrade.name}</div><div style="font-size: 1.1rem; color: #00ff00;">${upgrade.description}</div>`;
                button.onclick = () => { applyUpgrade(key); };
                upgradeOptionsContainer.appendChild(button);
            });
            levelUpModal?.classList.remove('hidden');
        }

        function applyUpgrade(key) {
            powerUpTypes[key].apply(playerStats);
            levelUpModal?.classList.add('hidden');
            gameState.gamePaused = false;
        }

        function askQuestion() {
            if (gameState.gameOver || gameState.gamePaused) return;
            gameState.gamePaused = true;
            const questionData = questionGenerator.generate();
            if (questionText) questionText.textContent = questionData.q;
            if (answerButtons) answerButtons.innerHTML = '';
            questionData.a.forEach((answer, index) => {
                const button = document.createElement('button');
                button.textContent = answer;
                button.className = "modal-button";
                button.style.cssText = "background: rgba(0,255,255,0.2); border: 3px solid #00ffff; padding: 15px; font-size: 1.3rem;";
                button.onclick = () => checkAnswer(index === questionData.c);
                answerButtons?.appendChild(button);
            });
            questionModal?.classList.remove('hidden');
        }

        function checkAnswer(isCorrect) {
            if (isCorrect) {
                gameState.correctAnswers++;
                playerStats.ammo += 25;
            } else {
                gameState.incorrectAnswers++;
            }
            questionModal?.classList.add('hidden');
            gameState.gamePaused = false;
        }

        function updateHUD() {
            if (ammoText) ammoText.textContent = playerStats.ammo;
            if (bombText) bombText.textContent = playerStats.bombs;
            if (scoreText) scoreText.textContent = gameState.score;
            if (levelText) levelText.textContent = playerStats.level;
            if (biomeText) biomeText.textContent = biomes[gameState.currentBiome].name;
            if (timeText) timeText.textContent = Math.floor(gameState.gameTime) + 's';
            if (xpBarFill) xpBarFill.style.width = `${(playerStats.xp / playerStats.xpToNextLevel) * 100}%`;
        }

        function updateCooldowns() {
            if (!touchDashCooldown) return;
            const now = Date.now();
            const timeSinceDash = now - playerStats.lastDashTime;
            const cooldownPercent = Math.min(1, timeSinceDash / playerStats.dashCooldown);

            if (cooldownPercent < 1) {
                if (touchDashCooldown.style.transition === 'none') {
                    touchDashCooldown.offsetHeight;
                    touchDashCooldown.style.transition = 'transform 0.1s linear';
                }
                touchDashCooldown.style.transform = `translateY(${(1 - cooldownPercent) * 100}%)`;
            } else {
                touchDashCooldown.style.transform = 'translateY(100%)';
            }
        }

        // === Update Loop ===
        app.on('update', function(dt) {
            if (gameState.gameOver || gameState.gamePaused || !gameState.player) return;

            gameState.gameTime += dt;

            // Handle input
            handleInput(dt);

            // Update player
            updatePlayer(dt);

            // Update enemies
            updateEnemies(dt);

            // Update projectiles
            updateProjectiles(dt);

            // Update enemy projectiles
            updateEnemyProjectiles(dt);

            // Update XP orbs
            updateXpOrbs(dt);

            // Handle collisions
            handleCollisions();

            // Spawn enemies
            spawnEnemies(dt);

            // Check boss spawns
            checkBossSpawns();

            // Update camera
            updateCamera(dt);

            // Update HUD
            updateHUD();
            updateCooldowns();
        });

        function handleInput(dt) {
            if (!gameState.player || playerStats.isDashing) return;

            let targetVX = 0, targetVZ = 0;

            if (gameState.isTouchDevice) {
                targetVX = gameState.moveInput.x * playerStats.speed;
                targetVZ = gameState.moveInput.y * playerStats.speed;
            } else {
                if (gameState.keys['KeyW'] || gameState.keys['ArrowUp']) targetVZ = -playerStats.speed;
                if (gameState.keys['KeyS'] || gameState.keys['ArrowDown']) targetVZ = playerStats.speed;
                if (gameState.keys['KeyA'] || gameState.keys['ArrowLeft']) targetVX = -playerStats.speed;
                if (gameState.keys['KeyD'] || gameState.keys['ArrowRight']) targetVX = playerStats.speed;
                if (targetVX !== 0 && targetVZ !== 0) {
                    const length = Math.sqrt(targetVX * targetVX + targetVZ * targetVZ);
                    targetVX = (targetVX / length) * playerStats.speed;
                    targetVZ = (targetVZ / length) * playerStats.speed;
                }
            }

            const friction = biomes[gameState.currentBiome].friction;
            const lerpFactor = Math.min(1, (1 - friction) * 60 * dt);

            playerStats.vx = playerStats.vx * (1 - lerpFactor) + targetVX * lerpFactor;
            playerStats.vy = playerStats.vy * (1 - lerpFactor) + targetVZ * lerpFactor;
        }

        function updatePlayer(dt) {
            if (playerStats.isDashing) {
                playerStats.dashTimer -= dt;
                playerStats.vx = playerStats.dashTargetVX;
                playerStats.vy = playerStats.dashTargetVZ;
                if (playerStats.dashTimer <= 0) {
                    playerStats.isDashing = false;
                    playerStats.vx = 0;
                    playerStats.vy = 0;
                }
            }

            const pos = gameState.player.getPosition();
            const newX = Math.max(-world.width / 2, Math.min(world.width / 2, pos.x + playerStats.vx * dt));
            const newZ = Math.max(-world.height / 2, Math.min(world.height / 2, pos.z + playerStats.vy * dt));
            gameState.player.setPosition(newX, pos.y, newZ);

            // Aiming
            let closestEnemy = null;
            let minDistSq = Infinity;
            gameState.enemies.forEach(e => {
                const enemyPos = e.getPosition();
                const dx = enemyPos.x - pos.x;
                const dz = enemyPos.z - pos.z;
                const distSq = dx * dx + dz * dz;
                if (distSq < minDistSq) {
                    minDistSq = distSq;
                    closestEnemy = e;
                }
            });

            if (closestEnemy) {
                const enemyPos = closestEnemy.getPosition();
                playerStats.weaponAngle = Math.atan2(enemyPos.z - pos.z, enemyPos.x - pos.x);
            } else {
                playerStats.weaponAngle = -Math.PI / 2;
            }

            // Shooting
            if (gameState.keys['Space'] || gameState.keys['mouseLeft'] || (gameState.isTouchDevice && gameState.keys['touchShoot'])) {
                shoot(playerStats.weaponAngle);
            }
        }

        function updateEnemies(dt) {
            const playerPos = gameState.player.getPosition();

            for (let i = 0; i < gameState.enemies.length; i++) {
                const e = gameState.enemies[i];
                const enemyPos = e.getPosition();

                const dx = playerPos.x - enemyPos.x;
                const dz = playerPos.z - enemyPos.z;
                const distSq = dx * dx + dz * dz;

                if (distSq > e.userData.size * e.userData.size) {
                    const dist = Math.sqrt(distSq);
                    const newX = enemyPos.x + (dx / dist) * e.userData.speed * dt;
                    const newZ = enemyPos.z + (dz / dist) * e.userData.speed * dt;
                    e.setPosition(newX, enemyPos.y, newZ);
                }

                if (e.userData.isBoss) {
                    const now = Date.now();
                    if (now - e.userData.lastShotTime >= e.userData.shootCooldown) {
                        e.userData.lastShotTime = now;
                        bossShoot(e);
                    }
                }
            }
        }

        function updateProjectiles(dt) {
            for (let i = gameState.projectiles.length - 1; i >= 0; i--) {
                const p = gameState.projectiles[i];
                const pos = p.getPosition();

                const newX = pos.x + p.userData.vx * dt;
                const newZ = pos.z + p.userData.vz * dt;
                p.setPosition(newX, pos.y, newZ);

                p.userData.lifetime -= dt;
                if (p.userData.lifetime <= 0 || Math.abs(newX) > world.width || Math.abs(newZ) > world.height) {
                    app.root.removeChild(p);
                    p.destroy();
                    gameState.projectiles.splice(i, 1);
                }
            }
        }

        function updateEnemyProjectiles(dt) {
            for (let i = gameState.enemyProjectiles.length - 1; i >= 0; i--) {
                const p = gameState.enemyProjectiles[i];
                const pos = p.getPosition();

                const newX = pos.x + p.userData.vx * dt;
                const newZ = pos.z + p.userData.vz * dt;
                p.setPosition(newX, pos.y, newZ);

                p.userData.lifetime -= dt;
                if (p.userData.lifetime <= 0 || Math.abs(newX) > world.width || Math.abs(newZ) > world.height) {
                    app.root.removeChild(p);
                    p.destroy();
                    gameState.enemyProjectiles.splice(i, 1);
                }
            }
        }

        function updateXpOrbs(dt) {
            const playerPos = gameState.player.getPosition();

            for (let i = 0; i < gameState.xpOrbs.length; i++) {
                const orb = gameState.xpOrbs[i];
                const orbPos = orb.getPosition();

                const dx = playerPos.x - orbPos.x;
                const dz = playerPos.z - orbPos.z;
                const distSq = dx * dx + dz * dz;

                if (distSq < (playerStats.pickupRadius / 10) * (playerStats.pickupRadius / 10)) {
                    const speed = 30 * dt;
                    const dist = Math.sqrt(distSq);
                    if (dist > 0) {
                        const newX = orbPos.x + (dx / dist) * speed;
                        const newZ = orbPos.z + (dz / dist) * speed;
                        orb.setPosition(newX, orbPos.y, newZ);
                    }
                }
            }
        }

        function handleCollisions() {
            if (!gameState.player) return;
            const playerPos = gameState.player.getPosition();

            // Projectile vs Enemy
            for (let pi = gameState.projectiles.length - 1; pi >= 0; pi--) {
                const p = gameState.projectiles[pi];
                const pPos = p.getPosition();

                for (let ei = gameState.enemies.length - 1; ei >= 0; ei--) {
                    const e = gameState.enemies[ei];
                    if (p.userData.hitEnemies?.includes(e.userData.id)) continue;

                    const ePos = e.getPosition();
                    const dx = ePos.x - pPos.x;
                    const dz = ePos.z - pPos.z;
                    const distSq = dx * dx + dz * dz;

                    if (distSq < (e.userData.size + 0.4) * (e.userData.size + 0.4)) {
                        handleEnemyHit(e, p.userData.damage, ei);

                        if (!p.userData.hitEnemies) p.userData.hitEnemies = [];
                        p.userData.hitEnemies.push(e.userData.id);

                        if (p.userData.pierceCount <= 0) {
                            app.root.removeChild(p);
                            p.destroy();
                            gameState.projectiles.splice(pi, 1);
                            break;
                        } else {
                            p.userData.pierceCount--;
                        }
                    }
                }
            }

            // Player vs Enemy
            if (!playerStats.isDashing) {
                for (let i = gameState.enemies.length - 1; i >= 0; i--) {
                    const e = gameState.enemies[i];
                    const ePos = e.getPosition();
                    const dx = playerPos.x - ePos.x;
                    const dz = playerPos.z - ePos.z;
                    const distSq = dx * dx + dz * dz;

                    if (distSq < (2 + e.userData.size) * (2 + e.userData.size)) {
                        playerStats.health -= e.userData.damage * 0.016;
                        if (playerStats.health <= 0) {
                            playerStats.health = 0;
                            endGame();
                        }
                    }
                }
            }

            // Player vs XP Orb
            for (let i = gameState.xpOrbs.length - 1; i >= 0; i--) {
                const orb = gameState.xpOrbs[i];
                const orbPos = orb.getPosition();
                const dx = playerPos.x - orbPos.x;
                const dz = playerPos.z - orbPos.z;
                const distSq = dx * dx + dz * dz;

                if (distSq < 2 * 2) {
                    gainXp(orb.userData.value);
                    app.root.removeChild(orb);
                    orb.destroy();
                    gameState.xpOrbs.splice(i, 1);
                }
            }

            // Enemy Projectiles vs Player
            if (!playerStats.isDashing) {
                for (let i = gameState.enemyProjectiles.length - 1; i >= 0; i--) {
                    const p = gameState.enemyProjectiles[i];
                    const pPos = p.getPosition();
                    const dx = playerPos.x - pPos.x;
                    const dz = playerPos.z - pPos.z;
                    const distSq = dx * dx + dz * dz;

                    if (distSq < (2 + 0.5) * (2 + 0.5)) {
                        playerStats.health -= p.userData.damage;
                        app.root.removeChild(p);
                        p.destroy();
                        gameState.enemyProjectiles.splice(i, 1);

                        if (playerStats.health <= 0) {
                            playerStats.health = 0;
                            endGame();
                        }
                    }
                }
            }
        }

        function spawnEnemies(dt) {
            gameState.spawnTimer -= dt;
            const spawnInterval = Math.max(0.1, 1.5 - gameState.gameTime / 120);
            const maxEnemies = 20 + playerStats.level * 10;

            if (gameState.spawnTimer <= 0 && gameState.enemies.length < maxEnemies) {
                spawnEnemy();
                gameState.spawnTimer = spawnInterval * (0.8 + Math.random() * 0.4);
            }
        }

        function checkBossSpawns() {
            if (playerStats.level >= 3 && !gameState.bossSpawnedLevel3) {
                gameState.bossSpawnedLevel3 = true;
                spawnBoss();
            }
            if (playerStats.level >= 5 && !gameState.bossSpawnedLevel5) {
                gameState.bossSpawnedLevel5 = true;
                spawnBoss();
            }
            if (playerStats.level >= 10 && !gameState.bossSpawnedLevel10) {
                gameState.bossSpawnedLevel10 = true;
                spawnBoss();
            }
        }

        function updateCamera(dt) {
            if (!gameState.player || !cameraEntity) return;

            const playerPos = gameState.player.getPosition();
            const cameraPos = cameraEntity.getPosition();

            const targetX = playerPos.x;
            const targetY = 20;
            const targetZ = playerPos.z - 50;

            const lerpFactor = 0.1;
            const newX = cameraPos.x + (targetX - cameraPos.x) * lerpFactor;
            const newY = cameraPos.y + (targetY - cameraPos.y) * lerpFactor;
            const newZ = cameraPos.z + (targetZ - cameraPos.z) * lerpFactor;

            cameraEntity.setPosition(newX, newY, newZ);
            cameraEntity.lookAt(playerPos.x, 0, playerPos.z);
        }

        // === Input Listeners ===
        window.addEventListener('keydown', (e) => {
            if (e.code) {
                gameState.keys[e.code] = true;
                if (e.code.toLowerCase() === 'keyq') askQuestion();
                if (e.code.toLowerCase() === 'shiftleft') triggerDash();
                if (e.code.toLowerCase() === 'keyb') triggerBomb();
            }
        });

        window.addEventListener('keyup', (e) => {
            if (e.code) gameState.keys[e.code] = false;
        });

        window.addEventListener('mousedown', (e) => {
            if (e.button === 0) gameState.keys['mouseLeft'] = true;
        });

        window.addEventListener('mouseup', (e) => {
            if (e.button === 0) gameState.keys['mouseLeft'] = false;
        });

        // Touch Controls
        function handleTouchStart(e) {
            const target = e.target;
            if (target.closest('.modal-button')) return;
            e.preventDefault();

            for (const touch of e.changedTouches) {
                const touchId = touch.identifier;
                if (gameState.activeTouches[touchId]) continue;

                const x = touch.clientX;
                const y = touch.clientY;

                if (touchBombButton) {
                    const bombRect = touchBombButton.getBoundingClientRect();
                    if (x > bombRect.left && x < bombRect.right && y > bombRect.top && y < bombRect.bottom) {
                        gameState.activeTouches[touchId] = { type: 'bomb' };
                        continue;
                    }
                }

                if (touchDashButton) {
                    const dashRect = touchDashButton.getBoundingClientRect();
                    if (x > dashRect.left && x < dashRect.right && y > dashRect.top && y < dashRect.bottom) {
                        gameState.activeTouches[touchId] = { type: 'dash' };
                        continue;
                    }
                }

                if (touchQuestionButton) {
                    const questionRect = touchQuestionButton.getBoundingClientRect();
                    if (x > questionRect.left && x < questionRect.right && y > questionRect.top && y < questionRect.bottom) {
                        gameState.activeTouches[touchId] = { type: 'question' };
                        continue;
                    }
                }

                if (joystickArea) {
                    const joystickRect = joystickArea.getBoundingClientRect();
                    if (x > joystickRect.left && x < joystickRect.right && y > joystickRect.top && y < joystickRect.bottom) {
                        if (gameState.joystickTouchId === null) {
                            gameState.joystickTouchId = touchId;
                            gameState.joystickStart.x = x;
                            gameState.joystickStart.y = y;
                            gameState.activeTouches[touchId] = { type: 'move', startX: x, startY: y, currentX: x, currentY: y };
                        }
                    }
                }

                if (shootArea) {
                    const shootRect = shootArea.getBoundingClientRect();
                    if (x > shootRect.left && x < shootRect.right && y > shootRect.top && y < shootRect.bottom) {
                        gameState.keys['touchShoot'] = true;
                        gameState.activeTouches[touchId] = { type: 'shoot' };
                    }
                }
            }
        }

        function handleTouchMove(e) {
            let shouldPreventDefault = false;

            for (const touch of e.changedTouches) {
                const touchId = touch.identifier;
                if (gameState.activeTouches[touchId]) {
                    shouldPreventDefault = true;

                    if (touchId === gameState.joystickTouchId && joystickArea && gameState.activeTouches[touchId].type === 'move') {
                        gameState.activeTouches[touchId].currentX = touch.clientX;
                        gameState.activeTouches[touchId].currentY = touch.clientY;

                        const deltaX = touch.clientX - gameState.joystickStart.x;
                        const deltaY = touch.clientY - gameState.joystickStart.y;
                        const angle = Math.atan2(deltaY, deltaX);
                        const distance = Math.min(joystickArea.clientWidth / 3, Math.hypot(deltaX, deltaY));
                        const moveX = distance * Math.cos(angle);
                        const moveY = distance * Math.sin(angle);
                        if (joystickNub) joystickNub.style.transform = `translate(-50%, -50%) translate(${moveX}px, ${moveY}px)`;

                        gameState.moveInput.x = moveX / (joystickArea.clientWidth / 3);
                        gameState.moveInput.y = moveY / (joystickArea.clientWidth / 3);
                    }
                }
            }

            if (shouldPreventDefault) e.preventDefault();
        }

        function handleTouchEnd(e) {
            let shouldPreventDefault = false;

            for (const touch of e.changedTouches) {
                const touchId = touch.identifier;
                if (gameState.activeTouches[touchId]) {
                    shouldPreventDefault = true;

                    if (touchId === gameState.joystickTouchId) {
                        gameState.joystickTouchId = null;
                        if (joystickNub) joystickNub.style.transform = 'translate(-50%, -50%)';
                        gameState.moveInput = { x: 0, y: 0 };
                    }
                    if (gameState.activeTouches[touchId]?.type === 'shoot') {
                        gameState.keys['touchShoot'] = false;
                    }
                    if (gameState.activeTouches[touchId]?.type === 'question') {
                        askQuestion();
                    }
                    if (gameState.activeTouches[touchId]?.type === 'dash') {
                        triggerDash();
                    }
                    if (gameState.activeTouches[touchId]?.type === 'bomb') {
                        triggerBomb();
                    }
                    delete gameState.activeTouches[touchId];
                }
            }

            if (shouldPreventDefault) e.preventDefault();
        }

        function detectTouchDevice() {
            gameState.isTouchDevice = ('ontouchstart' in window) || (navigator.maxTouchPoints > 0);
            if (touchControlsContainer) {
                if (gameState.isTouchDevice) {
                    touchControlsContainer.classList.remove('hidden');
                } else {
                    touchControlsContainer.classList.add('hidden');
                }
            }
        }

        // Initialize
        detectTouchDevice();

        if (restartButton) {
            restartButton.addEventListener('click', () => {
                gameOverModal?.classList.add('hidden');
                startGame();
            });
        }

        document.body.addEventListener('touchstart', handleTouchStart, { passive: false });
        document.body.addEventListener('touchmove', handleTouchMove, { passive: false });
        document.body.addEventListener('touchend', handleTouchEnd, { passive: false });
        document.body.addEventListener('touchcancel', handleTouchEnd, { passive: false });

        // Start game automatically
        startGame();
    </script>
</body>
</html>
