<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0, minimum-scale=1.0">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-fullscreen">
    <title>ESL Survivors 3D Wireframe - iPad Edition</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap" rel="stylesheet">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            margin: 0;
            background-color: #000;
            color: #00ff00;
            font-family: 'Orbitron', monospace;
            overflow: hidden;
            touch-action: none;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
        }
        #game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            background-color: #000;
        }
        canvas {
            display: block;
            width: 100%;
            height: 100%;
            background: radial-gradient(ellipse at center, #0a0a1a 0%, #000000 100%);
        }
        .modal {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 20, 0, 0.95);
            padding: 3rem;
            border-radius: 20px;
            border: 3px solid #00ff00;
            box-shadow: 0 0 40px rgba(0, 255, 0, 0.8);
            text-align: center;
            z-index: 100;
            width: 90%;
            max-width: 700px;
            font-family: 'Orbitron', monospace;
            touch-action: auto;
        }
        .modal h1, .modal h2 {
            color: #00ff00;
            text-shadow: 0 0 10px #00ff00;
            font-size: 2.5rem;
            margin-bottom: 1.5rem;
        }
        .modal p {
            color: #00ff00;
            font-size: 1.2rem;
            margin-bottom: 1rem;
        }
        .modal-button {
            background-color: #00ff00;
            color: #000;
            font-family: 'Orbitron', monospace;
            font-size: 1.8rem;
            font-weight: bold;
            padding: 1.2rem 2rem;
            border-radius: 15px;
            border: 3px solid #00ff00;
            cursor: pointer;
            transition: all 0.2s ease;
            margin-top: 1.5rem;
            box-shadow: 0 6px #00aa00;
            min-height: 80px;
            touch-action: manipulation;
        }
        .modal-button:active {
            background-color: #00aa00;
            box-shadow: 0 2px #00aa00;
            transform: translateY(4px);
        }
        #xp-bar-container {
            width: 100%;
            height: 20px;
            background-color: #001100;
            border: 3px solid #00ff00;
            border-radius: 10px;
            overflow: hidden;
        }
        #xp-bar-fill {
            height: 100%;
            background: linear-gradient(90deg, #00ff00, #00aa00);
            width: 0%;
            transition: width 0.3s ease;
        }
        #touch-controls-container {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            top: 0;
            z-index: 20;
            pointer-events: none;
        }
        .joystick-area {
            position: absolute;
            bottom: 40px;
            left: 40px;
            width: 200px;
            height: 200px;
            background-color: rgba(0, 255, 0, 0.1);
            border: 4px solid rgba(0, 255, 0, 0.5);
            border-radius: 50%;
            pointer-events: auto;
            touch-action: none;
        }
        .joystick-nub {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 80px;
            height: 80px;
            background-color: rgba(0, 255, 0, 0.6);
            border: 4px solid rgba(0, 255, 0, 1);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            box-shadow: 0 0 20px rgba(0, 255, 0, 0.8);
        }
        #shoot-area {
            position: absolute;
            bottom: 0;
            right: 0;
            top: 0;
            left: 50%;
            pointer-events: auto;
            touch-action: none;
        }

        .touch-dash-button {
            position: absolute;
            bottom: 180px;
            right: 40px;
            width: 110px;
            height: 110px;
            background-color: rgba(0, 200, 0, 0.6);
            border: 4px solid rgba(0, 255, 0, 1);
            border-radius: 50%;
            pointer-events: auto;
            display: flex;
            align-items: center;
            justify-content: center;
            font-family: 'Orbitron', monospace;
            font-size: 1.5rem;
            font-weight: bold;
            color: white;
            z-index: 21;
            overflow: hidden;
            box-shadow: 0 0 25px rgba(0, 255, 0, 0.6);
            touch-action: manipulation;
        }
        .touch-dash-cooldown {
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background-color: rgba(0, 0, 0, 0.8);
            transform: translateY(100%);
            transition: transform 0.1s linear;
        }

        .touch-bomb-button {
            position: absolute;
            bottom: 320px;
            right: 40px;
            width: 110px;
            height: 110px;
            background-color: rgba(255, 100, 0, 0.6);
            border: 4px solid rgba(255, 150, 0, 1);
            border-radius: 50%;
            pointer-events: auto;
            display: flex;
            align-items: center;
            justify-content: center;
            font-family: 'Orbitron', monospace;
            font-size: 2.5rem;
            color: white;
            z-index: 21;
            box-shadow: 0 0 25px rgba(255, 100, 0, 0.6);
            touch-action: manipulation;
        }

        .touch-question-button {
            position: absolute;
            bottom: 40px;
            right: 40px;
            width: 130px;
            height: 130px;
            background-color: rgba(0, 255, 255, 0.6);
            border: 4px solid rgba(0, 255, 255, 1);
            border-radius: 50%;
            pointer-events: auto;
            display: flex;
            align-items: center;
            justify-content: center;
            font-family: 'Orbitron', monospace;
            font-size: 4rem;
            font-weight: bold;
            color: white;
            z-index: 21;
            box-shadow: 0 0 30px rgba(0, 255, 255, 0.8);
            touch-action: manipulation;
        }

        #hud {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            padding: 20px;
            font-size: 1.3rem;
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            color: #00ff00;
            background: linear-gradient(180deg, rgba(0,0,0,0.7) 0%, rgba(0,0,0,0) 100%);
            text-shadow: 0 0 5px #00ff00;
            z-index: 10;
        }

        #xp-hud {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            padding: 20px;
            background: linear-gradient(0deg, rgba(0,0,0,0.7) 0%, rgba(0,0,0,0) 100%);
            z-index: 10;
        }

        .hud-section {
            background: rgba(0, 255, 0, 0.1);
            padding: 15px;
            border: 2px solid #00ff00;
            border-radius: 10px;
        }

        .hidden { display: none !important; }
    </style>
</head>
<body>
    <div id="game-container">
        <canvas id="gameCanvas"></canvas>

        <div id="touch-controls-container" class="hidden">
            <div id="joystick-area" class="joystick-area">
                <div id="joystick-nub" class="joystick-nub"></div>
            </div>
            <div id="shoot-area"></div>
            <div id="touch-bomb-button" class="touch-bomb-button">ðŸ’£</div>
            <div id="touch-dash-button" class="touch-dash-button">
                DASH
                <div id="touch-dash-cooldown" class="touch-dash-cooldown"></div>
            </div>
            <div id="touch-question-button" class="touch-question-button">?</div>
        </div>

        <div id="hud" class="hidden">
            <div class="hud-section">
                <div>Ammo: <span id="ammo-text">50</span></div>
                <div>Bombs: <span id="bomb-text">3</span></div>
                <div>Score: <span id="score-text">0</span></div>
            </div>
            <div class="hud-section">
                <div>Level: <span id="level-text">1</span></div>
                <div>Biome: <span id="biome-text">Normal</span></div>
            </div>
            <div class="hud-section">
                <div>Time: <span id="time-text">0s</span></div>
            </div>
        </div>

        <div id="xp-hud" class="hidden">
            <div id="xp-bar-container">
                <div id="xp-bar-fill"></div>
            </div>
        </div>

        <div id="question-modal" class="modal hidden">
            <h2>Ammo Question!</h2>
            <p id="question-text" style="font-size: 1.5rem; margin: 2rem 0;"></p>
            <div id="answer-buttons" style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px;"></div>
        </div>

        <div id="level-up-modal" class="modal hidden">
            <h2>Level Up!</h2>
            <p>Choose an upgrade:</p>
            <div id="upgrade-options-container" style="display: flex; flex-direction: column; gap: 20px; margin-top: 20px;"></div>
        </div>

        <div id="game-over-modal" class="modal hidden">
            <h2 style="color: #ff0000; text-shadow: 0 0 10px #ff0000;">Game Over!</h2>
            <div style="text-align: left; font-size: 1.3rem; margin: 2rem 0; background: rgba(0,0,0,0.5); padding: 20px; border-radius: 10px;">
                <p>Enemies Defeated: <span id="final-score" style="float: right; font-weight: bold;">0</span></p>
                <p>Time Survived: <span id="final-time" style="float: right; font-weight: bold;">0s</span></p>
                <hr style="margin: 15px 0; border-color: #00ff00;">
                <p>Correct: <span id="final-questions-correct" style="float: right; color: #00ff00; font-weight: bold;">0</span></p>
                <p>Incorrect: <span id="final-questions-incorrect" style="float: right; color: #ff0000; font-weight: bold;">0</span></p>
            </div>
            <button id="restart-button" class="modal-button">Play Again</button>
        </div>
    </div>

    <script type="module">
        // === 3D Wireframe Engine ===
        class Vector3 {
            constructor(x = 0, y = 0, z = 0) {
                this.x = x;
                this.y = y;
                this.z = z;
            }

            add(v) {
                return new Vector3(this.x + v.x, this.y + v.y, this.z + v.z);
            }

            subtract(v) {
                return new Vector3(this.x - v.x, this.y - v.y, this.z - v.z);
            }

            multiply(scalar) {
                return new Vector3(this.x * scalar, this.y * scalar, this.z * scalar);
            }

            length() {
                return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
            }

            normalize() {
                const len = this.length();
                return len > 0 ? this.multiply(1 / len) : new Vector3();
            }
        }

        class Camera3D {
            constructor() {
                this.position = new Vector3(0, 0, -800);
                this.target = new Vector3(0, 0, 0);
                this.fov = 60;
                this.near = 0.1;
                this.far = 2000;
            }

            project(point, canvas) {
                const aspectRatio = canvas.width / canvas.height;
                const fovRad = (this.fov * Math.PI) / 180;
                const f = 1 / Math.tan(fovRad / 2);

                // Translate to camera space
                const translated = point.subtract(this.position);

                // Prevent division by zero
                if (translated.z >= 0) translated.z = 0.1;

                // Perspective projection
                const x = (translated.x * f) / (-translated.z * aspectRatio);
                const y = (translated.y * f) / -translated.z;

                // Convert to screen space
                const screenX = (x + 1) * canvas.width / 2;
                const screenY = (1 - y) * canvas.height / 2;

                return { x: screenX, y: screenY, z: translated.z };
            }
        }

        // DOM Elements
        const getEl = id => document.getElementById(id);
        const gameContainer = getEl('game-container');
        let canvas, ctx, hud, scoreText, levelText, timeText, xp_hud, xpBarFill,
            levelUpModal, upgradeOptionsContainer, gameOverModal, finalScore, finalTime,
            restartButton, touchControlsContainer, joystickArea, joystickNub, shootArea,
            ammoText, bombText, biomeText, questionModal, questionText, answerButtons,
            finalQuestionsCorrect, finalQuestionsIncorrect,
            touchQuestionButton, touchDashButton, touchDashCooldown, touchBombButton;

        function initUI() {
            canvas = getEl('gameCanvas');
            ctx = canvas.getContext('2d');
            hud = getEl('hud');
            ammoText = getEl('ammo-text');
            bombText = getEl('bomb-text');
            scoreText = getEl('score-text');
            levelText = getEl('level-text');
            biomeText = getEl('biome-text');
            timeText = getEl('time-text');
            xp_hud = getEl('xp-hud');
            xpBarFill = getEl('xp-bar-fill');
            questionModal = getEl('question-modal');
            questionText = getEl('question-text');
            answerButtons = getEl('answer-buttons');
            levelUpModal = getEl('level-up-modal');
            upgradeOptionsContainer = getEl('upgrade-options-container');
            gameOverModal = getEl('game-over-modal');
            finalScore = getEl('final-score');
            finalTime = getEl('final-time');
            finalQuestionsCorrect = getEl('final-questions-correct');
            finalQuestionsIncorrect = getEl('final-questions-incorrect');
            restartButton = getEl('restart-button');
            touchControlsContainer = getEl('touch-controls-container');
            joystickArea = getEl('joystick-area');
            joystickNub = getEl('joystick-nub');
            shootArea = getEl('shoot-area');
            touchQuestionButton = getEl('touch-question-button');
            touchDashButton = getEl('touch-dash-button');
            touchDashCooldown = getEl('touch-dash-cooldown');
            touchBombButton = getEl('touch-bomb-button');
        }

        // Game State
        const camera = new Camera3D();
        let player, enemies = [], projectiles = [], xpOrbs = [], particles = [];
        let enemyProjectiles = [], orbitalWeapons = [], stunProjectiles = [];
        let score = 0, gameTime = 0, spawnTimer = 0, gamePaused = false, gameOver = false;
        let correctAnswers = 0, incorrectAnswers = 0;
        let bossSpawnedLevel3 = false, bossSpawnedLevel5 = false, bossSpawnedLevel10 = false;
        let lastShotTime = 0, gameLoopId;
        let chargeStartTime = 0, isCharging = false;
        let killStreak = 0;
        let isTouchDevice = false;
        let joystickTouchId = null;
        let joystickStart = { x: 0, y: 0 };
        let moveInput = { x: 0, y: 0 };
        let activeTouches = {};
        let world = { width: 2000, height: 2000 };
        let currentBiome = 'normal';
        let lavaPits = [];

        const biomes = {
            normal: { name: 'Normal World', color: '#00ff00', gridColor: '#003300' },
            ice: { name: 'Ice World', color: '#00ffff', gridColor: '#003333', friction: 0.92 },
            heat: { name: 'Heat World', color: '#ff0000', gridColor: '#330000', lavaDamage: 2, maxLavaPits: 8 }
        };
        let biomeOrder = ['normal', 'ice', 'heat', 'normal'];
        let biomeIndex = 0;

        const playerStats = {
            x: 0, y: 0, z: 0, size: 20, speed: 250, health: 100, maxHealth: 100, ammo: 50,
            fireRate: 500, projectileSpeed: 350, projectileSize: 8, projectileDamage: 25,
            shotCount: 1, pickupRadius: 80, level: 1, xp: 0, xpToNextLevel: 100,
            pierce: 0, spread: 0, weaponAngle: 0, vx: 0, vy: 0,
            dashSpeed: 1000, dashDuration: 150, dashCooldown: 5000, lastDashTime: 0,
            isDashing: false, dashTimer: 0,
            bombs: 3, bombDamage: 100, bombRadius: 200, bombCooldown: 10000, lastBombTime: -10000
        };

        const enemyTypes = [
            { id_key: "Drone", name: "Drone", size: 20, speed: 180, health: 40, xp: 10, color: '#ff0000', damage: 5, maxHealth: 40 },
            { id_key: "Robot", name: "Robot", size: 50, speed: 40, health: 120, xp: 40, color: '#0000ff', damage: 10, maxHealth: 120 },
            { id_key: "Scout", name: "Scout", size: 15, speed: 220, health: 30, xp: 18, color: '#ffff00', damage: 4, maxHealth: 30 },
            { id_key: "Swarm", name: "Swarm", size: 7, speed: 250, health: 10, xp: 15, color: '#00ff88', damage: 1, maxHealth: 10 },
            { id_key: "Flyer", name: "Flyer", size: 12, speed: 280, health: 25, xp: 20, color: '#ff00ff', damage: 3, maxHealth: 25 },
            { id_key: "Tank", name: "Tank", size: 70, speed: 30, health: 300, xp: 60, color: '#666666', damage: 20, maxHealth: 300 },
            { id_key: "Assassin", name: "Assassin", size: 18, speed: 350, health: 20, xp: 35, color: '#8800ff', damage: 15, maxHealth: 20 }
        ];

        const bossType = {
            id_key: "Boss", name: "Boss", size: 80, speed: 90, health: 900, xp: 2000,
            color: '#ff0000', damage: 250, maxHealth: 900, isBoss: true, shootCooldown: 2000,
            lastShotTime: 0
        };

        const powerUpTypes = {
            'HEALTH': { name: "Health Pack", description: "+50 Max HP", apply: (p) => { p.maxHealth += 50; p.health = Math.min(p.maxHealth, p.health + 50); } },
            'SPEED': { name: "Speed Boost", description: "+80% Move Speed", apply: (p) => p.speed *= 1.8 },
            'FIRE_RATE': { name: "Rapid Fire", description: "-75% Firing Delay", apply: (p) => p.fireRate *= 0.25 },
            'DAMAGE': { name: "Damage Up", description: "+15 Damage", apply: (p) => p.projectileDamage += 15 },
            'MULTISHOT': { name: "Spread Shot", description: "+2 Projectiles", apply: (p) => p.shotCount += 2 },
            'PIERCE': { name: "Piercing Shot", description: "Shots pierce +2 enemies", apply: (p) => p.pierce += 2 },
            'PICKUP': { name: "XP Magnet", description: "+75% Pickup Radius", apply: (p) => p.pickupRadius *= 1.75 },
            'BOMB_CAPACITY': { name: "Bomb Cache", description: "+2 Bombs", apply: (p) => p.bombs += 2 },
            'DASH_COOLDOWN': { name: "Quick Dash", description: "-30% Dash Cooldown", apply: (p) => p.dashCooldown *= 0.7 }
        };

        // Question Generator (simplified for space)
        const questionGenerator = {
            verbBank: [
                { base: 'go', past: 'went', ing: 'going', pastParticiple: 'gone', object: 'to the store' },
                { base: 'eat', past: 'ate', ing: 'eating', pastParticiple: 'eaten', object: 'pizza' },
                { base: 'sleep', past: 'slept', ing: 'sleeping', pastParticiple: 'slept', object: 'well' },
                { base: 'run', past: 'ran', ing: 'running', pastParticiple: 'run', object: 'fast' }
            ],
            subjects: [
                { s: 'I', was: 'was' }, { s: 'You', was: 'were' }, { s: 'He', was: 'was' },
                { s: 'She', was: 'was' }, { s: 'They', was: 'were' }
            ],
            timeClauses: ['yesterday', 'last night', 'at 8 PM', 'last week'],
            getRandom(arr) { return arr[Math.floor(Math.random() * arr.length)]; },
            shuffle(arr) {
                let newArr = [...arr];
                for (let i = newArr.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [newArr[i], newArr[j]] = [newArr[j], newArr[i]];
                }
                return newArr;
            },
            createPastSimpleFill() {
                const verb = this.getRandom(this.verbBank);
                const subject = this.getRandom(this.subjects).s;
                const time = this.getRandom(this.timeClauses);
                const q = `${subject} [___] ${verb.object} ${time}.`;
                let answers = [verb.past, verb.base, verb.ing, verb.base + 's'];
                const shuffledAnswers = this.shuffle(answers);
                return { q, a: shuffledAnswers, c: shuffledAnswers.indexOf(verb.past) };
            },
            generate() {
                return this.createPastSimpleFill();
            }
        };

        // Game Init
        function init() {
            enemies = []; projectiles = []; xpOrbs = []; particles = [];
            enemyProjectiles = []; orbitalWeapons = []; stunProjectiles = []; lavaPits = [];
            score = 0; gameTime = 0; spawnTimer = 0; gamePaused = false; gameOver = false;
            correctAnswers = 0; incorrectAnswers = 0;
            bossSpawnedLevel3 = false; bossSpawnedLevel5 = false; bossSpawnedLevel10 = false;
            chargeStartTime = 0; isCharging = false; killStreak = 0;
            currentBiome = 'normal'; biomeIndex = 0;
            player = JSON.parse(JSON.stringify(playerStats));
            player.isDashing = false; player.dashTimer = 0; player.lastDashTime = 0;

            camera.position = new Vector3(player.x, player.y - 100, -800);
            camera.target = new Vector3(player.x, player.y, 0);

            updateHUD();
            updateCooldowns();
            [questionModal, levelUpModal, gameOverModal].forEach(m => { if(m) m.classList.add('hidden'); });
            if (gameLoopId) cancelAnimationFrame(gameLoopId);
            resizeCanvas();
            gameLoopId = requestAnimationFrame(gameLoop);
        }

        function startGame() {
            if(hud) hud.classList.remove('hidden');
            if(xp_hud) xp_hud.classList.remove('hidden');
            init();
        }

        function endGame() {
            gameOver = true;
            gamePaused = true;
            if(finalScore) finalScore.textContent = score;
            if(finalTime) finalTime.textContent = Math.floor(gameTime) + 's';
            if(finalQuestionsCorrect) finalQuestionsCorrect.textContent = correctAnswers;
            if(finalQuestionsIncorrect) finalQuestionsIncorrect.textContent = incorrectAnswers;
            if(gameOverModal) gameOverModal.classList.remove('hidden');
        }

        // Main Game Loop
        let lastTime = 0;
        function gameLoop(timestamp) {
            if (gameOver || gamePaused) {
                lastTime = timestamp;
                gameLoopId = requestAnimationFrame(gameLoop);
                return;
            }
            const delta = (timestamp - (lastTime || timestamp)) / 1000 || 0;
            lastTime = timestamp;
            gameTime += delta;

            handleInput(delta);
            update(delta);
            updateCamera3D();
            draw();

            gameLoopId = requestAnimationFrame(gameLoop);
        }

        // Input
        let keys = {};
        function handleInput(delta) {
            if (!player || player.isDashing) return;

            let targetVX = 0, targetVY = 0;

            if (isTouchDevice) {
                targetVX = moveInput.x * player.speed;
                targetVY = moveInput.y * player.speed;
            } else {
                if (keys['KeyW'] || keys['ArrowUp']) targetVY = -player.speed;
                if (keys['KeyS'] || keys['ArrowDown']) targetVY = player.speed;
                if (keys['KeyA'] || keys['ArrowLeft']) targetVX = -player.speed;
                if (keys['KeyD'] || keys['ArrowRight']) targetVX = player.speed;
                if (targetVX !== 0 && targetVY !== 0) {
                    const length = Math.sqrt(targetVX * targetVX + targetVY * targetVY);
                    targetVX = (targetVX / length) * player.speed;
                    targetVY = (targetVY / length) * player.speed;
                }
            }

            let lerpFactor = Math.min(1, 15 * delta);
            if (currentBiome === 'ice') lerpFactor = Math.min(1, 5 * delta);

            player.vx = (player.vx ?? 0) * (1 - lerpFactor) + targetVX * lerpFactor;
            player.vy = (player.vy ?? 0) * (1 - lerpFactor) + targetVY * lerpFactor;
        }

        // Update
        function update(delta) {
            if(!player || gameOver) return;
            updatePlayer(delta);
            updateEnemies(delta);
            updateProjectiles(delta);
            updateEnemyProjectiles(delta);
            updateDrops(delta);
            updateParticles(delta);
            handleCollisions();
            spawnEnemies(delta);
            checkBossSpawns();
            updateHUD();
            updateCooldowns();
        }

        function updatePlayer(delta) {
            if (player.isDashing) {
                player.dashTimer -= delta;
                player.vx = player.dashTargetVX;
                player.vy = player.dashTargetVY;
                if (player.dashTimer <= 0) {
                    player.isDashing = false;
                    player.vx = 0;
                    player.vy = 0;
                }
                player.x += player.vx * delta;
                player.y += player.vy * delta;
                player.x = Math.max(-world.width/2, Math.min(world.width/2, player.x));
                player.y = Math.max(-world.height/2, Math.min(world.height/2, player.y));

                if (Math.random() > 0.3) {
                    particles.push(createParticle(player.x, player.y, player.z, biomes[currentBiome].color, 3, 0.4));
                }
                return;
            }

            player.x += player.vx * delta;
            player.y += player.vy * delta;
            player.x = Math.max(-world.width/2, Math.min(world.width/2, player.x));
            player.y = Math.max(-world.height/2, Math.min(world.height/2, player.y));

            // Aiming
            let closestEnemy = null;
            let minDistSq = Infinity;
            enemies.forEach(e => {
                const dx = e.x - player.x; const dy = e.y - player.y;
                const distSq = dx*dx + dy*dy;
                if (distSq < minDistSq) {
                    minDistSq = distSq;
                    closestEnemy = e;
                }
            });

            if (closestEnemy) {
                player.weaponAngle = Math.atan2(closestEnemy.y - player.y, closestEnemy.x - player.x);
            } else {
                player.weaponAngle = -Math.PI / 2;
            }

            // Shooting
            if (keys['Space'] || keys['mouseLeft'] || (isTouchDevice && keys['touchShoot'])) {
                shoot(player.weaponAngle);
            }
        }

        function updateEnemies(delta) {
            enemies.forEach(e => {
                if (e.stunned && e.stunnedUntil > Date.now()) return;
                else if (e.stunned) e.stunned = false;

                const dx = player.x - e.x;
                const dy = player.y - e.y;
                const distSq = dx*dx + dy*dy;
                if (distSq > e.size * e.size) {
                    const dist = Math.sqrt(distSq);
                    e.x += (dx / dist) * e.speed * delta;
                    e.y += (dy / dist) * e.speed * delta;
                }

                if (e.isBoss) {
                    const now = Date.now();
                    if (now - e.lastShotTime >= e.shootCooldown) {
                        e.lastShotTime = now;
                        bossShoot(e);
                    }
                }
            });
        }

        function updateProjectiles(delta) {
            for (let i = projectiles.length - 1; i >= 0; i--) {
                const p = projectiles[i];
                p.x += p.vx * delta;
                p.y += p.vy * delta;
                p.lifetime -= delta;
                if (p.lifetime <= 0 || Math.abs(p.x) > world.width || Math.abs(p.y) > world.height) {
                    projectiles.splice(i, 1);
                }
            }
        }

        function updateEnemyProjectiles(delta) {
            for (let i = enemyProjectiles.length - 1; i >= 0; i--) {
                const p = enemyProjectiles[i];
                p.x += p.vx * delta;
                p.y += p.vy * delta;
                p.lifetime -= delta;
                if (p.lifetime <= 0 || Math.abs(p.x) > world.width || Math.abs(p.y) > world.height) {
                    enemyProjectiles.splice(i, 1);
                }
            }
        }

        function bossShoot(boss) {
            if (!player) return;
            const dx = player.x - boss.x;
            const dy = player.y - boss.y;
            const angle = Math.atan2(dy, dx);
            const speed = 200;

            enemyProjectiles.push({
                x: boss.x, y: boss.y, z: boss.z,
                vx: Math.cos(angle) * speed,
                vy: Math.sin(angle) * speed,
                size: 10, damage: 20, lifetime: 5, color: '#ff0000'
            });
        }

        function updateDrops(delta) {
            xpOrbs.forEach(orb => {
                const dx = player.x - orb.x;
                const dy = player.y - orb.y;
                const distSq = dx*dx + dy*dy;
                if (distSq < player.pickupRadius * player.pickupRadius) {
                    const speed = 300 * delta;
                    const dist = Math.sqrt(distSq);
                    orb.x += (dx / dist) * speed;
                    orb.y += (dy / dist) * speed;
                }
            });
        }

        function createParticle(x, y, z, color, size, lifetime) {
            return {
                x, y, z: z || 0, color, size, lifetime: lifetime || 0.5,
                vx: (Math.random() - 0.5) * 150,
                vy: (Math.random() - 0.5) * 150,
                vz: (Math.random() - 0.5) * 50,
                drag: 0.95
            };
        }

        function spawnParticleEmitter(x, y, z, color, count) {
            for (let i = 0; i < count; i++) {
                particles.push(createParticle(x, y, z, color, Math.random() * 3 + 1, Math.random() * 0.5 + 0.3));
            }
        }

        function updateParticles(delta) {
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.x += p.vx * delta;
                p.y += p.vy * delta;
                p.z += p.vz * delta;
                p.vx *= p.drag;
                p.vy *= p.drag;
                p.vz *= p.drag;
                p.lifetime -= delta;
                p.size = Math.max(0, p.size - delta * 2);
                if (p.lifetime <= 0 || p.size <= 0) {
                    particles.splice(i, 1);
                }
            }
        }

        function handleCollisions() {
            if (!player) return;

            // Projectile vs Enemy
            for (let pi = projectiles.length - 1; pi >= 0; pi--) {
                const p = projectiles[pi];
                for (let ei = enemies.length - 1; ei >= 0; ei--) {
                    const e = enemies[ei];
                    if (p.hitEnemies?.includes(e.id)) continue;

                    const dx = e.x - p.x; const dy = e.y - p.y;
                    const distSq = dx*dx + dy*dy;
                    if (distSq < (e.size + p.size) * (e.size + p.size)) {
                        handleEnemyHit(e, p.damage);
                        spawnParticleEmitter(p.x, p.y, 0, '#ffffff', 3);
                        if (!p.hitEnemies) p.hitEnemies = [];
                        p.hitEnemies.push(e.id);
                        if (p.pierceCount <= 0) {
                            projectiles.splice(pi, 1);
                            break;
                        } else {
                            p.pierceCount--;
                        }
                    }
                }
            }

            // Player vs Enemy
            for (let i = enemies.length - 1; i >= 0; i--) {
                const e = enemies[i];
                if (player.isDashing) continue;
                const dx = player.x - e.x; const dy = player.y - e.y;
                if (dx*dx + dy*dy < (player.size + e.size) * (player.size + e.size)) {
                    const damageReduction = player.damageReduction || 0;
                    const actualDamage = e.damage * (1 - damageReduction);
                    player.health -= actualDamage;
                    const angle = Math.atan2(dy, dx);
                    e.x -= Math.cos(angle) * e.size * 0.5;
                    e.y -= Math.sin(angle) * e.size * 0.5;
                    if (player.health <= 0) {
                        player.health = 0;
                        endGame();
                    }
                }
            }

            // Player vs XP Orb
            for (let i = xpOrbs.length - 1; i >= 0; i--) {
                const orb = xpOrbs[i];
                const dx = player.x - orb.x; const dy = player.y - orb.y;
                if(dx*dx + dy*dy < player.size * player.size) {
                    gainXp(orb.value);
                    xpOrbs.splice(i, 1);
                }
            }

            // Enemy Projectiles vs Player
            for (let i = enemyProjectiles.length - 1; i >= 0; i--) {
                const p = enemyProjectiles[i];
                if (player.isDashing) continue;
                const dx = player.x - p.x; const dy = player.y - p.y;
                if (dx*dx + dy*dy < (player.size + p.size) * (player.size + p.size)) {
                    const damageReduction = player.damageReduction || 0;
                    const actualDamage = p.damage * (1 - damageReduction);
                    player.health -= actualDamage;
                    spawnParticleEmitter(p.x, p.y, 0, '#ff0000', 5);
                    enemyProjectiles.splice(i, 1);
                    if (player.health <= 0) {
                        player.health = 0;
                        endGame();
                    }
                }
            }
        }

        function handleEnemyHit(enemy, damage) {
            enemy.health -= damage;
            if (enemy.health <= 0) {
                const index = enemies.findIndex(e => e.id === enemy.id);
                if (index > -1) {
                    killEnemy(enemies[index], index);
                }
            }
        }

        function killEnemy(enemy, index) {
            score++;
            killStreak++;
            createXpOrb(enemy.x, enemy.y, enemy.z, enemy.xp);
            spawnParticleEmitter(enemy.x, enemy.y, enemy.z, enemy.color, 20);

            if (enemy.isBoss) {
                changeBiome();
            }

            enemies.splice(index, 1);
        }

        function spawnEnemies(delta) {
            spawnTimer -= delta;
            const spawnInterval = Math.max(0.1, 1.5 - gameTime / 120);
            const maxEnemies = 20 + player.level * 10;
            if (spawnTimer <= 0 && enemies.length < maxEnemies) {
                spawnEnemy();
                spawnTimer = spawnInterval * (0.8 + Math.random() * 0.4);
            }
        }

        function spawnEnemy() {
            const type = enemyTypes[Math.floor(Math.random() * enemyTypes.length)];
            const spawnDist = 800;
            const angle = Math.random() * Math.PI * 2;
            const x = player.x + Math.cos(angle) * spawnDist;
            const y = player.y + Math.sin(angle) * spawnDist;

            enemies.push({
                id: Math.random(), x: x, y: y, z: 0, ...type,
                health: type.health * (1 + gameTime / 90),
                maxHealth: type.health * (1 + gameTime / 90)
            });
        }

        function checkBossSpawns() {
            if (!player) return;
            if (player.level >= 3 && !bossSpawnedLevel3) {
                bossSpawnedLevel3 = true;
                spawnBoss();
            }
            if (player.level >= 5 && !bossSpawnedLevel5) {
                bossSpawnedLevel5 = true;
                spawnBoss();
            }
            if (player.level >= 10 && !bossSpawnedLevel10) {
                bossSpawnedLevel10 = true;
                spawnBoss();
            }
        }

        function spawnBoss() {
            const spawnDist = 1000;
            const angle = Math.random() * Math.PI * 2;
            const x = player.x + Math.cos(angle) * spawnDist;
            const y = player.y + Math.sin(angle) * spawnDist;

            const boss = {
                id: Math.random(), x: x, y: y, z: 0, ...bossType,
                health: bossType.health,
                maxHealth: bossType.health,
                lastShotTime: Date.now()
            };

            enemies.push(boss);
        }

        function changeBiome() {
            biomeIndex = (biomeIndex + 1) % biomeOrder.length;
            currentBiome = biomeOrder[biomeIndex];
            lavaPits = [];
            const biomeInfo = biomes[currentBiome];
            spawnParticleEmitter(player.x, player.y, 0, biomeInfo.color, 50);
        }

        function shoot(angle) {
            if (!player) return;
            if (player.ammo <= 0) {
                askQuestion();
                return;
            }
            if (Date.now() - lastShotTime < player.fireRate) return;

            player.ammo--;
            lastShotTime = Date.now();
            const spreadAngle = 0.15;

            for (let i = 0; i < player.shotCount; i++) {
                let currentAngle = angle;
                if (player.shotCount > 1) {
                    const totalSpread = spreadAngle * (player.shotCount - 1);
                    currentAngle += totalSpread / 2 - spreadAngle * i;
                }

                const muzzleX = player.x + Math.cos(currentAngle) * (player.size * 1.2);
                const muzzleY = player.y + Math.sin(currentAngle) * (player.size * 1.2);
                spawnParticleEmitter(muzzleX, muzzleY, 0, biomes[currentBiome].color, 3);

                let damage = player.projectileDamage;
                let isCrit = false;
                if (player.critChance && Math.random() < player.critChance) {
                    damage *= 2;
                    isCrit = true;
                }

                projectiles.push({
                    x: player.x, y: player.y, z: 0,
                    vx: Math.cos(currentAngle) * player.projectileSpeed,
                    vy: Math.sin(currentAngle) * player.projectileSpeed,
                    size: player.projectileSize,
                    damage: damage,
                    lifetime: player.projectileLifetime || 3,
                    pierceCount: player.pierce,
                    hitEnemies: [],
                    isCrit: isCrit
                });
            }
        }

        function createXpOrb(x, y, z, value) {
            xpOrbs.push({ x: x, y: y, z: z || 0, size: 5, value: value, color: '#00ff00' });
        }

        function triggerDash() {
            if (!player || player.isDashing || gamePaused) return;
            const now = Date.now();
            if (now - player.lastDashTime < player.dashCooldown) return;

            player.lastDashTime = now;
            player.isDashing = true;
            player.dashTimer = player.dashDuration / 1000;

            let dashDirX = player.vx;
            let dashDirY = player.vy;
            let mag = Math.hypot(dashDirX, dashDirY);

            if (mag < 10) {
                dashDirX = Math.cos(player.weaponAngle);
                dashDirY = Math.sin(player.weaponAngle);
            } else {
                dashDirX /= mag;
                dashDirY /= mag;
            }

            player.dashTargetVX = dashDirX * player.dashSpeed;
            player.dashTargetVY = dashDirY * player.dashSpeed;

            if (touchDashCooldown) {
                touchDashCooldown.style.transition = 'none';
                touchDashCooldown.style.transform = 'translateY(0%)';
            }
        }

        function triggerBomb() {
            if (!player || gamePaused) return;
            if (player.bombs <= 0) return;
            const now = Date.now();
            if (now - player.lastBombTime < player.bombCooldown) return;

            player.bombs--;
            player.lastBombTime = now;

            spawnParticleEmitter(player.x, player.y, 0, '#ffaa00', 100);
            spawnParticleEmitter(player.x, player.y, 0, '#ff4400', 80);

            for (let i = enemies.length - 1; i >= 0; i--) {
                const e = enemies[i];
                const dx = e.x - player.x;
                const dy = e.y - player.y;
                const dist = Math.sqrt(dx*dx + dy*dy);
                if (dist < player.bombRadius) {
                    handleEnemyHit(e, player.bombDamage);
                }
            }

            for (let i = enemyProjectiles.length - 1; i >= 0; i--) {
                const p = enemyProjectiles[i];
                const dx = p.x - player.x;
                const dy = p.y - player.y;
                const dist = Math.sqrt(dx*dx + dy*dy);
                if (dist < player.bombRadius) {
                    enemyProjectiles.splice(i, 1);
                }
            }
        }

        // === 3D Wireframe Drawing ===
        function draw() {
            if (!ctx) return;
            ctx.fillStyle = '#000000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            if (!player) return;

            ctx.save();

            drawWorld3D();
            xpOrbs.forEach(orb => drawXpOrb3D(orb));
            projectiles.forEach(p => drawProjectile3D(p));
            enemyProjectiles.forEach(p => drawEnemyProjectile3D(p));
            enemies.forEach(e => drawEnemy3D(e));
            particles.forEach(p => drawParticle3D(p));
            drawPlayer3D();

            ctx.restore();
        }

        function drawWorld3D() {
            const biomeInfo = biomes[currentBiome];
            ctx.strokeStyle = biomeInfo.gridColor;
            ctx.lineWidth = 1;

            const gridSize = 200;
            const gridRange = 2000;

            // Draw grid floor
            for (let x = -gridRange; x <= gridRange; x += gridSize) {
                const p1 = camera.project(new Vector3(x, -gridRange, 0), canvas);
                const p2 = camera.project(new Vector3(x, gridRange, 0), canvas);
                if (p1.z < 0 && p2.z < 0) {
                    ctx.beginPath();
                    ctx.moveTo(p1.x, p1.y);
                    ctx.lineTo(p2.x, p2.y);
                    ctx.stroke();
                }
            }

            for (let y = -gridRange; y <= gridRange; y += gridSize) {
                const p1 = camera.project(new Vector3(-gridRange, y, 0), canvas);
                const p2 = camera.project(new Vector3(gridRange, y, 0), canvas);
                if (p1.z < 0 && p2.z < 0) {
                    ctx.beginPath();
                    ctx.moveTo(p1.x, p1.y);
                    ctx.lineTo(p2.x, p2.y);
                    ctx.stroke();
                }
            }
        }

        function drawPlayer3D() {
            const biomeColor = biomes[currentBiome].color;

            // Draw player as wireframe pyramid
            const height = player.size * 2;
            const baseSize = player.size;

            const vertices = [
                new Vector3(player.x, player.y - baseSize, player.z),
                new Vector3(player.x + baseSize, player.y + baseSize, player.z),
                new Vector3(player.x - baseSize, player.y + baseSize, player.z),
                new Vector3(player.x, player.y, player.z + height)
            ];

            const projected = vertices.map(v => camera.project(v, canvas));

            if (projected.every(p => p.z < 0)) {
                ctx.strokeStyle = biomeColor;
                ctx.lineWidth = 3;
                ctx.shadowBlur = 15;
                ctx.shadowColor = biomeColor;

                // Base triangle
                ctx.beginPath();
                ctx.moveTo(projected[0].x, projected[0].y);
                ctx.lineTo(projected[1].x, projected[1].y);
                ctx.lineTo(projected[2].x, projected[2].y);
                ctx.closePath();
                ctx.stroke();

                // Lines to apex
                for (let i = 0; i < 3; i++) {
                    ctx.beginPath();
                    ctx.moveTo(projected[i].x, projected[i].y);
                    ctx.lineTo(projected[3].x, projected[3].y);
                    ctx.stroke();
                }

                ctx.shadowBlur = 0;
            }

            // Health bar
            const barWidth = baseSize * 3;
            const barHeight = 8;
            const barPos = camera.project(new Vector3(player.x, player.y - baseSize - 30, player.z), canvas);
            if (barPos.z < 0) {
                ctx.fillStyle = '#330000';
                ctx.fillRect(barPos.x - barWidth / 2, barPos.y, barWidth, barHeight);
                ctx.fillStyle = '#00ff00';
                ctx.fillRect(barPos.x - barWidth / 2, barPos.y, barWidth * (player.health / player.maxHealth), barHeight);
            }
        }

        function drawEnemy3D(e) {
            const size = e.size;

            // Wireframe cube
            const vertices = [
                new Vector3(e.x - size/2, e.y - size/2, e.z - size/2),
                new Vector3(e.x + size/2, e.y - size/2, e.z - size/2),
                new Vector3(e.x + size/2, e.y + size/2, e.z - size/2),
                new Vector3(e.x - size/2, e.y + size/2, e.z - size/2),
                new Vector3(e.x - size/2, e.y - size/2, e.z + size/2),
                new Vector3(e.x + size/2, e.y - size/2, e.z + size/2),
                new Vector3(e.x + size/2, e.y + size/2, e.z + size/2),
                new Vector3(e.x - size/2, e.y + size/2, e.z + size/2)
            ];

            const projected = vertices.map(v => camera.project(v, canvas));

            if (projected.some(p => p.z < 0)) {
                ctx.strokeStyle = e.color;
                ctx.lineWidth = e.isBoss ? 4 : 2;
                ctx.shadowBlur = e.isBoss ? 20 : 10;
                ctx.shadowColor = e.color;

                // Bottom face
                drawWireframeFace(projected, [0, 1, 2, 3]);
                // Top face
                drawWireframeFace(projected, [4, 5, 6, 7]);
                // Connecting edges
                for (let i = 0; i < 4; i++) {
                    ctx.beginPath();
                    ctx.moveTo(projected[i].x, projected[i].y);
                    ctx.lineTo(projected[i+4].x, projected[i+4].y);
                    ctx.stroke();
                }

                ctx.shadowBlur = 0;
            }

            // Health bar
            if (e.health < e.maxHealth) {
                const barWidth = size * 2;
                const barHeight = 5;
                const barPos = camera.project(new Vector3(e.x, e.y - size - 15, e.z), canvas);
                if (barPos.z < 0) {
                    ctx.fillStyle = '#660000';
                    ctx.fillRect(barPos.x - barWidth / 2, barPos.y, barWidth, barHeight);
                    ctx.fillStyle = e.color;
                    ctx.fillRect(barPos.x - barWidth / 2, barPos.y, barWidth * (e.health / e.maxHealth), barHeight);
                }
            }
        }

        function drawWireframeFace(projected, indices) {
            ctx.beginPath();
            ctx.moveTo(projected[indices[0]].x, projected[indices[0]].y);
            for (let i = 1; i < indices.length; i++) {
                ctx.lineTo(projected[indices[i]].x, projected[indices[i]].y);
            }
            ctx.closePath();
            ctx.stroke();
        }

        function drawProjectile3D(p) {
            const pos = camera.project(new Vector3(p.x, p.y, p.z), canvas);
            if (pos.z < 0) {
                const biomeColor = biomes[currentBiome].color;
                ctx.fillStyle = p.isCrit ? '#ff0000' : biomeColor;
                ctx.shadowBlur = 10;
                ctx.shadowColor = ctx.fillStyle;
                ctx.beginPath();
                ctx.arc(pos.x, pos.y, p.size * (p.isCrit ? 1.5 : 1), 0, Math.PI * 2);
                ctx.fill();
                ctx.shadowBlur = 0;
            }
        }

        function drawEnemyProjectile3D(p) {
            const pos = camera.project(new Vector3(p.x, p.y, p.z), canvas);
            if (pos.z < 0) {
                ctx.fillStyle = p.color;
                ctx.shadowBlur = 10;
                ctx.shadowColor = p.color;
                ctx.beginPath();
                ctx.arc(pos.x, pos.y, p.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.shadowBlur = 0;
            }
        }

        function drawXpOrb3D(orb) {
            const pos = camera.project(new Vector3(orb.x, orb.y, orb.z), canvas);
            if (pos.z < 0) {
                ctx.fillStyle = orb.color;
                ctx.shadowBlur = 15;
                ctx.shadowColor = orb.color;
                ctx.beginPath();
                ctx.arc(pos.x, pos.y, orb.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.shadowBlur = 0;
            }
        }

        function drawParticle3D(p) {
            const pos = camera.project(new Vector3(p.x, p.y, p.z), canvas);
            if (pos.z < 0) {
                ctx.globalAlpha = Math.max(0, p.lifetime / 0.5);
                ctx.fillStyle = p.color;
                ctx.beginPath();
                ctx.arc(pos.x, pos.y, p.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1.0;
            }
        }

        // Camera
        function updateCamera3D() {
            if (!player || !canvas) return;

            const targetX = player.x;
            const targetY = player.y - 100;
            const targetZ = -800;

            const lerpFactor = 0.1;
            camera.position.x += (targetX - camera.position.x) * lerpFactor;
            camera.position.y += (targetY - camera.position.y) * lerpFactor;
            camera.position.z += (targetZ - camera.position.z) * lerpFactor;

            camera.target.x = player.x;
            camera.target.y = player.y;
            camera.target.z = 0;
        }

        // UI
        function updateHUD() {
            if(ammoText) ammoText.textContent = player?.ammo ?? 'N/A';
            if(bombText) bombText.textContent = player?.bombs ?? 0;
            if(scoreText) scoreText.textContent = score;
            if(levelText) levelText.textContent = player?.level ?? 1;
            if(biomeText) biomeText.textContent = biomes[currentBiome].name;
            if(timeText) timeText.textContent = Math.floor(gameTime) + 's';
            if(xpBarFill && player) xpBarFill.style.width = `${player ? (player.xp / player.xpToNextLevel) * 100 : 0}%`;
        }

        function updateCooldowns() {
            if (!player || !touchDashCooldown) return;
            const now = Date.now();
            const timeSinceDash = now - player.lastDashTime;
            const cooldownPercent = Math.min(1, timeSinceDash / player.dashCooldown);

            if (cooldownPercent < 1) {
                if (touchDashCooldown.style.transition === 'none') {
                    touchDashCooldown.offsetHeight;
                    touchDashCooldown.style.transition = 'transform 0.1s linear';
                }
                touchDashCooldown.style.transform = `translateY(${(1 - cooldownPercent) * 100}%)`;
            } else {
                touchDashCooldown.style.transform = 'translateY(100%)';
            }
        }

        function gainXp(amount) {
            if (!player) return;
            player.xp += amount;
            if (player.xp >= player.xpToNextLevel) {
                player.level++;
                player.xp -= player.xpToNextLevel;
                player.xpToNextLevel = Math.floor(player.xpToNextLevel * 1.5);
                showLevelUpModal();
            }
        }

        function showLevelUpModal() {
            gamePaused = true;
            if (!upgradeOptionsContainer) return;
            upgradeOptionsContainer.innerHTML = '';
            const availableUpgrades = Object.keys(powerUpTypes);
            const chosenUpgrades = [];
            while(chosenUpgrades.length < 3 && availableUpgrades.length > 0) {
                const randIndex = Math.floor(Math.random() * availableUpgrades.length);
                chosenUpgrades.push(availableUpgrades.splice(randIndex, 1)[0]);
            }
            chosenUpgrades.forEach(key => {
                const upgrade = powerUpTypes[key];
                const button = document.createElement('button');
                button.className = "modal-button";
                button.style.cssText = "background: rgba(0,255,0,0.2); border: 3px solid #00ff00; padding: 20px; text-align: left; width: 100%;";
                button.innerHTML = `<div style="font-size: 1.5rem; font-weight: bold; color: #00ff00; margin-bottom: 10px;">${upgrade.name}</div><div style="font-size: 1.1rem; color: #00ff00;">${upgrade.description}</div>`;
                button.onclick = () => { applyUpgrade(key); };
                upgradeOptionsContainer.appendChild(button);
            });
            if(levelUpModal) levelUpModal.classList.remove('hidden');
        }

        function applyUpgrade(key) {
            if (!player) return;
            powerUpTypes[key].apply(player);
            if(levelUpModal) levelUpModal.classList.add('hidden');
            gamePaused = false;
        }

        function askQuestion() {
            if (gameOver || gamePaused) return;
            gamePaused = true;
            const questionData = questionGenerator.generate();
            if(questionText) questionText.textContent = questionData.q;
            if(answerButtons) answerButtons.innerHTML = '';
            questionData.a.forEach((answer, index) => {
                const button = document.createElement('button');
                button.textContent = answer;
                button.className = "modal-button";
                button.style.cssText = "background: rgba(0,255,255,0.2); border: 3px solid #00ffff; padding: 15px; font-size: 1.3rem;";
                button.onclick = () => checkAnswer(index === questionData.c);
                if(answerButtons) answerButtons.appendChild(button);
            });
            if(questionModal) questionModal.classList.remove('hidden');
        }

        function checkAnswer(isCorrect) {
            if (!player) return;
            if (isCorrect) {
                correctAnswers++;
                player.ammo += 25;
            } else {
                incorrectAnswers++;
            }
            if(questionModal) questionModal.classList.add('hidden');
            gamePaused = false;
        }

        // Input Listeners
        window.addEventListener('keydown', (e) => {
            if (e.code) {
                keys[e.code] = true;
                if(e.code.toLowerCase() === 'keyq') askQuestion();
                if(e.code.toLowerCase() === 'shiftleft') triggerDash();
                if(e.code.toLowerCase() === 'keyb') triggerBomb();
            }
        });
        window.addEventListener('keyup', (e) => {
            if (e.code) keys[e.code] = false;
        });
        window.addEventListener('mousedown', (e) => { if(e.button === 0) keys['mouseLeft'] = true; });
        window.addEventListener('mouseup', (e) => { if(e.button === 0) keys['mouseLeft'] = false; });
        window.addEventListener('resize', resizeCanvas);

        // Touch Listeners
        function handleTouchStart(e) {
            const target = e.target;
            if (target.closest('.modal-button')) return;
            e.preventDefault();

            for (const touch of e.changedTouches) {
                const touchId = touch.identifier;
                if (activeTouches[touchId]) continue;

                const x = touch.clientX; const y = touch.clientY;

                if (touchBombButton) {
                    const bombRect = touchBombButton.getBoundingClientRect();
                    if (x > bombRect.left && x < bombRect.right && y > bombRect.top && y < bombRect.bottom) {
                        activeTouches[touchId] = { type: 'bomb' };
                        continue;
                    }
                }

                if (touchDashButton) {
                    const dashRect = touchDashButton.getBoundingClientRect();
                    if (x > dashRect.left && x < dashRect.right && y > dashRect.top && y < dashRect.bottom) {
                        activeTouches[touchId] = { type: 'dash' };
                        continue;
                    }
                }

                if (touchQuestionButton) {
                    const questionRect = touchQuestionButton.getBoundingClientRect();
                    if (x > questionRect.left && x < questionRect.right && y > questionRect.top && y < questionRect.bottom) {
                        activeTouches[touchId] = { type: 'question' };
                        continue;
                    }
                }

                if (joystickArea) {
                    const joystickRect = joystickArea.getBoundingClientRect();
                    if (x > joystickRect.left && x < joystickRect.right && y > joystickRect.top && y < joystickRect.bottom) {
                        if (joystickTouchId === null) {
                            joystickTouchId = touchId;
                            joystickStart.x = x;
                            joystickStart.y = y;
                            activeTouches[touchId] = { type: 'move', startX: x, startY: y, currentX: x, currentY: y };
                        }
                    }
                }
                if (shootArea) {
                    const shootRect = shootArea.getBoundingClientRect();
                    if (x > shootRect.left && x < shootRect.right && y > shootRect.top && y < shootRect.bottom) {
                        keys['touchShoot'] = true;
                        activeTouches[touchId] = { type: 'shoot' };
                    }
                }
            }
        }

        function handleTouchMove(e) {
            let shouldPreventDefault = false;

            for (const touch of e.changedTouches) {
                const touchId = touch.identifier;
                if (activeTouches[touchId]) {
                    shouldPreventDefault = true;

                    if (touchId === joystickTouchId && joystickArea && activeTouches[touchId].type === 'move') {
                        activeTouches[touchId].currentX = touch.clientX;
                        activeTouches[touchId].currentY = touch.clientY;

                        const deltaX = touch.clientX - joystickStart.x;
                        const deltaY = touch.clientY - joystickStart.y;
                        const angle = Math.atan2(deltaY, deltaX);
                        const distance = Math.min(joystickArea.clientWidth / 3, Math.hypot(deltaX, deltaY));
                        const moveX = distance * Math.cos(angle);
                        const moveY = distance * Math.sin(angle);
                        if(joystickNub) joystickNub.style.transform = `translate(-50%, -50%) translate(${moveX}px, ${moveY}px)`;

                        moveInput.x = moveX / (joystickArea.clientWidth / 3);
                        moveInput.y = moveY / (joystickArea.clientWidth / 3);
                    }
                }
            }

            if (shouldPreventDefault) e.preventDefault();
        }

        function handleTouchEnd(e) {
            let shouldPreventDefault = false;

            for (const touch of e.changedTouches) {
                const touchId = touch.identifier;
                if (activeTouches[touchId]) {
                    shouldPreventDefault = true;

                    if (touchId === joystickTouchId) {
                        joystickTouchId = null;
                        if(joystickNub) joystickNub.style.transform = 'translate(-50%, -50%)';
                        moveInput = { x: 0, y: 0 };
                    }
                    if (activeTouches[touchId]?.type === 'shoot') {
                        keys['touchShoot'] = false;
                    }
                    if (activeTouches[touchId]?.type === 'question') {
                        askQuestion();
                    }
                    if (activeTouches[touchId]?.type === 'dash') {
                        triggerDash();
                    }
                    if (activeTouches[touchId]?.type === 'bomb') {
                        triggerBomb();
                    }
                    delete activeTouches[touchId];
                }
            }

            if (shouldPreventDefault) e.preventDefault();
        }

        function detectTouchDevice() {
            isTouchDevice = ('ontouchstart' in window) || (navigator.maxTouchPoints > 0);
            if(touchControlsContainer) {
                if (isTouchDevice) {
                    touchControlsContainer.classList.remove('hidden');
                } else {
                    touchControlsContainer.classList.add('hidden');
                }
            }
        }

        function resizeCanvas() {
            if(canvas) {
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
            }
        }

        // Initialization
        initUI();
        resizeCanvas();
        detectTouchDevice();

        if (restartButton) restartButton.addEventListener('click', () => {
            if(gameOverModal) gameOverModal.classList.add('hidden');
            startGame();
        });

        gameContainer.addEventListener('touchstart', handleTouchStart, { passive: false });
        gameContainer.addEventListener('touchmove', handleTouchMove, { passive: false });
        gameContainer.addEventListener('touchend', handleTouchEnd, { passive: false });
        gameContainer.addEventListener('touchcancel', handleTouchEnd, { passive: false });

        // Start game automatically
        startGame();
    </script>
</body>
</html>
